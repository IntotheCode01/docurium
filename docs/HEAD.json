{"tag.h":{"meta":{"brief":"Git tag parsing routines","defgroup":"git_tag Git tag management","file":"git2/tag.h","ingroup":"Git"},"functions":[{"return":"GIT_INLINE(int)","function":"git_tag_lookup","line":42,"args":"git_tag **tag, git_repository *repo, const git_oid *id","comments":["/**","* Lookup a tag object from the repository.","*","* @param tag pointer to the looked up tag","* @param repo the repo to use when locating the tag.","* @param id identity of the tag to locate.","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_INLINE(void)","function":"git_tag_close","line":55,"args":"git_tag *tag","comments":["/**","* Close an open tag","*","* This is a wrapper around git_object_close()","*","* IMPORTANT:","* It *is* necessary to call this method when you stop","* using a tag. Failure to do so will cause a memory leak.","*","* @param tag the tag to close","*/"]},{"return":"GIT_EXTERN(const git_oid *)","function":"git_tag_id","line":73,"args":"git_tag *tag","comments":["/**","* Get the id of a tag.","*","* @param tag a previously loaded tag.","* @return object identity for the tag.","*/"]},{"return":"GIT_EXTERN(int)","function":"git_tag_target","line":81,"args":"git_object **target, git_tag *t","comments":["/**","* Get the tagged object of a tag","*","* This method performs a repository lookup for the","* given object and returns it","*","* @param target pointer where to store the target","* @param tag a previously loaded tag.","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(const git_oid *)","function":"git_tag_target_oid","line":93,"args":"git_tag *t","comments":["/**","* Get the OID of the tagged object of a tag","*","* @param tag a previously loaded tag.","* @return pointer to the OID","*/"]},{"return":"GIT_EXTERN(git_otype)","function":"git_tag_type","line":101,"args":"git_tag *t","comments":["/**","* Get the type of a tag's tagged object","*","* @param tag a previously loaded tag.","* @return type of the tagged object","*/"]},{"return":"GIT_EXTERN(const char *)","function":"git_tag_name","line":109,"args":"git_tag *t","comments":["/**","* Get the name of a tag","*","* @param tag a previously loaded tag.","* @return name of the tag","*/"]},{"return":"GIT_EXTERN(const git_signature *)","function":"git_tag_tagger","line":117,"args":"git_tag *t","comments":["/**","* Get the tagger (author) of a tag","*","* @param tag a previously loaded tag.","* @return reference to the tag's author","*/"]},{"return":"GIT_EXTERN(const char *)","function":"git_tag_message","line":125,"args":"git_tag *t","comments":["/**","* Get the message of a tag","*","* @param tag a previously loaded tag.","* @return message of the tag","*/"]}]},"signature.h":{"meta":{"brief":"Git signature creation","defgroup":"git_signature Git signature creation","file":"git2/signature.h","ingroup":"Git"},"functions":[{"return":"GIT_EXTERN(git_signature *)","function":"git_signature_new","line":40,"args":"const char *name, const char *email, git_time_t time, int offset","comments":["/**","* Create a new action signature. The signature must be freed","* manually or using git_signature_free","*","* @param name name of the person","* @param mail email of the person","* @param time time when the action happened","* @param offset timezone offset in minutes for the time","* @return the new sig, NULL on out of memory","*/"]},{"return":"GIT_EXTERN(git_signature *)","function":"git_signature_now","line":52,"args":"const char *name, const char *email","comments":["/**","* Create a new action signature with a timestamp of 'now'. The","* signature must be freed manually or using git_signature_free","*","* @param name name of the person","* @param email email of the person","* @return the new sig, NULL on out of memory","*/"]},{"return":"GIT_EXTERN(git_signature *)","function":"git_signature_dup","line":63,"args":"const git_signature *sig","comments":["/**","* Create a copy of an existing signature.","*","* All internal strings are also duplicated.","* @param sig signature to duplicated","* @return a copy of sig, NULL on out of memory","*/"]},{"return":"GIT_EXTERN(void)","function":"git_signature_free","line":72,"args":"git_signature *sig","comments":["/**","* Free an existing signature","*","* @param sig signature to free","*/"]}]},"odb.h":{"meta":{"brief":"Git object database routines","defgroup":"git_odb Git object database routines","file":"git2/odb.h","ingroup":"Git"},"functions":[{"return":"GIT_EXTERN(int)","function":"git_odb_new","line":42,"args":"git_odb **out","comments":["/**","* Create a new object database with no backends.","*","* Before the ODB can be used for read/writing, a custom database","* backend must be manually added using `git_odb_add_backend()`","*","* @param out location to store the database pointer, if opened.","*            Set to NULL if the open failed.","* @return GIT_SUCCESS if the database was created; otherwise an error","*         code describing why the open was not possible.","*/"]},{"return":"GIT_EXTERN(int)","function":"git_odb_open","line":55,"args":"git_odb **out, const char *objects_dir","comments":["/**","* Create a new object database and automatically add","* the two default backends:","*","*\t- git_odb_backend_loose: read and write loose object files","*\t\tfrom disk, assuming `objects_dir` as the Objects folder","*","*\t- git_odb_backend_pack: read objects from packfiles,","*\t\tassuming `objects_dir` as the Objects folder which","*\t\tcontains a 'pack/' folder with the corresponding data","*","* @param out location to store the database pointer, if opened.","*            Set to NULL if the open failed.","* @param objects_dir path of the backends' \"objects\" directory.","* @return GIT_SUCCESS if the database opened; otherwise an error","*         code describing why the open was not possible.","*/"]},{"return":"GIT_EXTERN(int)","function":"git_odb_add_backend","line":74,"args":"git_odb *odb, git_odb_backend *backend, int priority","comments":["/**","* Add a custom backend to an existing Object DB","*","* Read <odb_backends.h> for more information.","*","* @param odb database to add the backend to","* @paramm backend pointer to a git_odb_backend instance","* @return 0 on sucess; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_odb_add_alternate","line":85,"args":"git_odb *odb, git_odb_backend *backend, int priority","comments":["/**","* Add a custom backend to an existing Object DB; this","* backend will work as an alternate.","*","* Alternate backends are always checked for objects *after*","* all the main backends have been exhausted.","*","* Writing is disabled on alternate backends.","*","* Read <odb_backends.h> for more information.","*","* @param odb database to add the backend to","* @paramm backend pointer to a git_odb_backend instance","* @return 0 on sucess; error code otherwise","*/"]},{"return":"GIT_EXTERN(void)","function":"git_odb_close","line":102,"args":"git_odb *db","comments":["/**","* Close an open object database.","*","* @param db database pointer to close.  If NULL no action is taken.","*/"]},{"return":"GIT_EXTERN(int)","function":"git_odb_read","line":109,"args":"git_odb_object **out, git_odb *db, const git_oid *id","comments":["/**","* Read an object from the database.","*","* This method queries all avaiable ODB backends","* trying to read the given OID.","*","* The returned object is reference counted and","* internally cached, so it should be closed","* by the user once it's no longer in use.","*","* @param out pointer where to store the read object","* @param db database to search for the object in.","* @param id identity of the object to read.","* @return","* - GIT_SUCCESS if the object was read;","* - GIT_ENOTFOUND if the object is not in the database.","*/"]},{"return":"GIT_EXTERN(int)","function":"git_odb_read_header","line":128,"args":"size_t *len_p, git_otype *type_p, git_odb *db, const git_oid *id","comments":["/**","* Read the header of an object from the database, without","* reading its full contents.","*","* The header includes the length and the type of an object.","*","* Note that most backends do not support reading only the header","* of an object, so the whole object will be read and then the","* header will be returned.","*","* @param len_p pointer where to store the length","* @param type_p pointer where to store the type","* @param db database to search for the object in.","* @param id identity of the object to read.","* @return","* - GIT_SUCCESS if the object was read;","* - GIT_ENOTFOUND if the object is not in the database.","*/"]},{"return":"GIT_EXTERN(int)","function":"git_odb_exists","line":148,"args":"git_odb *db, const git_oid *id","comments":["/**","* Determine if the given object can be found in the object database.","*","* @param db database to be searched for the given object.","* @param id the object to search for.","* @return","* - 1, if the object was found","* - 0, otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_odb_write","line":159,"args":"git_oid *oid, git_odb *odb, const void *data, size_t len, git_otype type","comments":["/**","* Write an object directly into the ODB","*","* This method writes a full object straight into the ODB.","* For most cases, it is preferred to write objects through a write","* stream, which is both faster and less memory intensive, specially","* for big objects.","*","* This method is provided for compatibility with custom backends","* which are not able to support streaming writes","*","* @param oid pointer to store the OID result of the write","* @param odb object database where to store the object","* @param data buffer with the data to storr","* @param len size of the buffer","* @param type type of the data to store","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_odb_open_wstream","line":179,"args":"git_odb_stream **stream, git_odb *db, size_t size, git_otype type","comments":["/**","* Open a stream to write an object into the ODB","*","* The type and final length of the object must be specified","* when opening the stream.","*","* The returned stream will be of type `GIT_STREAM_WRONLY` and","* will have the following methods:","*","*\t\t- stream->write: write `n` bytes into the stream","*\t\t- stream->finalize_write: close the stream and store the object in","*\t\t\tthe odb","*\t\t- stream->free: free the stream","*","* The streaming write won't be effective until `stream->finalize_write`","* is called and returns without an error","*","* The stream must always be free'd or will leak memory.","*","* @see git_odb_stream","*","* @param stream pointer where to store the stream","* @param db object database where the stream will write","* @param size final size of the object that will be written","* @param type type of the object that will be written","* @return 0 if the stream was created; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_odb_open_rstream","line":208,"args":"git_odb_stream **stream, git_odb *db, const git_oid *oid","comments":["/**","* Open a stream to read an object from the ODB","*","* Note that most backends do *not* support streaming reads","* because they store their objects as compressed/delta'ed blobs.","*","* It's recommended to use `git_odb_read` instead, which is","* assured to work on all backends.","*","* The returned stream will be of type `GIT_STREAM_RDONLY` and","* will have the following methods:","*","*\t\t- stream->read: read `n` bytes from the stream","*\t\t- stream->free: free the stream","*","* The stream must always be free'd or will leak memory.","*","* @see git_odb_stream","*","* @param stream pointer where to store the stream","* @param db object database where the stream will read from","* @param oid oid of the object the stream will read from","* @return 0 if the stream was created; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_odb_hash","line":234,"args":"git_oid *id, const void *data, size_t len, git_otype type","comments":["/**","* Determine the object-ID (sha1 hash) of a data buffer","*","* The resulting SHA-1 OID will the itentifier for the data","* buffer as if the data buffer it were to written to the ODB.","*","* @param id the resulting object-ID.","* @param data data to hash","* @param len size of the data","* @param type of the data to hash","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(void)","function":"git_odb_object_close","line":248,"args":"git_odb_object *object","comments":["/**","* Close an ODB object","*","* This method must always be called once a `git_odb_object` is no","* longer needed, otherwise memory will leak.","*","* @param object object to close","*/"]},{"return":"GIT_EXTERN(const git_oid *)","function":"git_odb_object_id","line":258,"args":"git_odb_object *object","comments":["/**","* Return the OID of an ODB object","*","* This is the OID from which the object was read from","*","* @param object the object","* @return a pointer to the OID","*/"]},{"return":"GIT_EXTERN(const void *)","function":"git_odb_object_data","line":268,"args":"git_odb_object *object","comments":["/**","* Return the data of an ODB object","*","* This is the uncompressed, raw data as read from the ODB,","* without the leading header.","*","* This pointer is owned by the object and shall not be free'd.","*","* @param object the object","* @return a pointer to the data","*/"]},{"return":"GIT_EXTERN(size_t)","function":"git_odb_object_size","line":281,"args":"git_odb_object *object","comments":["/**","* Return the size of an ODB object","*","* This is the real size of the `data` buffer, not the","* actual size of the object.","*","* @param object the object","* @return the size","*/"]},{"return":"GIT_EXTERN(git_otype)","function":"git_odb_object_type","line":292,"args":"git_odb_object *object","comments":["/**","* Return the type of an ODB object","*","* @param object the object","* @return the type","*/"]}]},"types.h":{"meta":{"brief":"libgit2 base & compatibility types","defgroup":null,"file":"git2/types.h","ingroup":"Git"},"functions":[]},"zlib.h":{"meta":{"brief":"Git data compression routines","defgroup":"git_zlib Git data compression routines","file":"git2/zlib.h","ingroup":"Git"},"functions":[]},"tree.h":{"meta":{"brief":"Git tree parsing, loading routines","defgroup":"git_tree Git tree parsing, loading routines","file":"git2/tree.h","ingroup":"Git"},"functions":[{"return":"GIT_INLINE(int)","function":"git_tree_lookup","line":42,"args":"git_tree **tree, git_repository *repo, const git_oid *id","comments":["/**","* Lookup a tree object from the repository.","*","* @param tree pointer to the looked up tree","* @param repo the repo to use when locating the tree.","* @param id identity of the tree to locate.","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_INLINE(void)","function":"git_tree_close","line":55,"args":"git_tree *tree","comments":["/**","* Close an open tree","*","* This is a wrapper around git_object_close()","*","* IMPORTANT:","* It *is* necessary to call this method when you stop","* using a tree. Failure to do so will cause a memory leak.","*","* @param tree the tree to close","*/"]},{"return":"GIT_EXTERN(const git_oid *)","function":"git_tree_id","line":73,"args":"git_tree *tree","comments":["/**","* Get the id of a tree.","*","* @param tree a previously loaded tree.","* @return object identity for the tree.","*/"]},{"return":"GIT_EXTERN(size_t)","function":"git_tree_entrycount","line":81,"args":"git_tree *tree","comments":["/**","* Get the number of entries listed in a tree","*","* @param tree a previously loaded tree.","* @return the number of entries in the tree","*/"]},{"return":"GIT_EXTERN(const git_tree_entry *)","function":"git_tree_entry_byname","line":89,"args":"git_tree *tree, const char *filename","comments":["/**","* Lookup a tree entry by its filename","*","* @param tree a previously loaded tree.","* @param filename the filename of the desired entry","* @return the tree entry; NULL if not found","*/"]},{"return":"GIT_EXTERN(const git_tree_entry *)","function":"git_tree_entry_byindex","line":98,"args":"git_tree *tree, int idx","comments":["/**","* Lookup a tree entry by its position in the tree","*","* @param tree a previously loaded tree.","* @param idx the position in the entry list","* @return the tree entry; NULL if not found","*/"]},{"return":"GIT_EXTERN(unsigned int)","function":"git_tree_entry_attributes","line":107,"args":"const git_tree_entry *entry","comments":["/**","* Get the UNIX file attributes of a tree entry","*","* @param entry a tree entry","* @return attributes as an integer","*/"]},{"return":"GIT_EXTERN(const char *)","function":"git_tree_entry_name","line":115,"args":"const git_tree_entry *entry","comments":["/**","* Get the filename of a tree entry","*","* @param entry a tree entry","* @return the name of the file","*/"]},{"return":"GIT_EXTERN(const git_oid *)","function":"git_tree_entry_id","line":123,"args":"const git_tree_entry *entry","comments":["/**","* Get the id of the object pointed by the entry","*","* @param entry a tree entry","* @return the oid of the object","*/"]},{"return":"GIT_EXTERN(int)","function":"git_tree_create_fromindex","line":141,"args":"git_oid *oid, git_index *index","comments":["/**","* Write a tree to the ODB from the index file","*","* This method will scan the index and write a representation","* of its current state back to disk; it recursively creates","* tree objects for each of the subtrees stored in the index,","* but only returns the OID of the root tree. This is the OID","* that can be used e.g. to create a commit.","*","* The index instance cannot be bare, and needs to be associated","* to an existing repository.","*","* @param oid Pointer where to store the written tree","* @param index Index to write","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_treebuilder_create","line":159,"args":"git_treebuilder **builder_p, const git_tree *source","comments":["/**","* Create a new tree builder.","*","* The tree builder can be used to create or modify","* trees in memory and write them as tree objects to the","* database.","*","* If the `source` parameter is not NULL, the tree builder","* will be initialized with the entries of the given tree.","*","* If the `source` parameter is NULL, the tree builder will","* have no entries and will have to be filled manually.","*","* @param builder_p Pointer where to store the tree builder","* @param source Source tree to initialize the builder (optional)","* @return 0 on sucess; error code otherwise","*/"]},{"return":"GIT_EXTERN(void)","function":"git_treebuilder_clear","line":178,"args":"git_treebuilder *bld","comments":["/**","* Clear all the entires in the builder","*","* @param bld Builder to clear","*/"]},{"return":"GIT_EXTERN(void)","function":"git_treebuilder_free","line":185,"args":"git_treebuilder *bld","comments":["/**","* Free a tree builder","*","* This will clear all the entries and free to builder.","* Failing to free the builder after you're done using it","* will result in a memory leak","*","* @param bld Builder to free","*/"]},{"return":"GIT_EXTERN(const git_tree_entry *)","function":"git_treebuilder_get","line":196,"args":"git_treebuilder *bld, const char *filename","comments":["/**","* Get an entry from the builder from its filename","*","* The returned entry is owned by the builder and should","* not be freed manually.","*","* @param bld Tree builder","* @param filename Name of the entry","* @return pointer to the entry; NULL if not found","*/"]},{"return":"GIT_EXTERN(int)","function":"git_treebuilder_insert","line":208,"args":"git_tree_entry **entry_out, git_treebuilder *bld, const char *filename, const git_oid *id, unsigned int attributes","comments":["/**","* Add or update an entry to the builder","*","* Insert a new entry for `filename` in the builder with the","* given attributes.","*","* if an entry named `filename` already exists, its attributes","* will be updated with the given ones.","*","* The optional pointer `entry_out` can be used to retrieve a","* pointer to the newly created/updated entry.","*","* @param entry_out Pointer to store the entry (optional)","* @param bld Tree builder","* @param filename Filename of the entry","* @param id SHA1 oid of the entry","* @param attributes Folder attributes of the entry","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_treebuilder_remove","line":229,"args":"git_treebuilder *bld, const char *filename","comments":["/**","* Remove an entry from the builder by its filename","*","* @param bld Tree builder","* @param filename Filename of the entry to remove","*/"]},{"return":"GIT_EXTERN(void)","function":"git_treebuilder_filter","line":237,"args":"git_treebuilder *bld, int (*filter)(const git_tree_entry *, void *), void *payload","comments":["/**","* Filter the entries in the tree","*","* The `filter` callback will be called for each entry","* in the tree with a pointer to the entry and the","* provided `payload`: if the callback returns 1, the","* entry will be filtered (removed from the builder).","*","* @param bld Tree builder","* @param filter Callback to filter entries","*/"]},{"return":"GIT_EXTERN(int)","function":"git_treebuilder_write","line":250,"args":"git_oid *oid, git_repository *repo, git_treebuilder *bld","comments":["/**","* Write the contents of the tree builder as a tree object","*","* The tree builder will be written to the given `repo`, and","* it's identifying SHA1 hash will be stored in the `oid`","* pointer.","*","* @param oid Pointer where to store the written OID","* @param repo Repository where to store the object","* @param bld Tree builder to write","* @return 0 on success; error code otherwise","*/"]}]},"refs.h":{"meta":{"brief":"Git reference management routines","defgroup":"git_reference Git reference management routines","file":"git2/refs.h","ingroup":"Git"},"functions":[{"return":"GIT_EXTERN(int)","function":"git_reference_lookup","line":41,"args":"git_reference **reference_out, git_repository *repo, const char *name","comments":["/**","* Lookup a reference by its name in a repository.","*","* The generated reference is owned by the repository and","* should not be freed by the user.","*","* @param reference_out pointer to the looked-up reference","* @param repo the repository to look up the reference","* @param name the long name for the reference (e.g. HEAD, ref/heads/master, refs/tags/v0.1.0, ...)","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_create_symbolic","line":54,"args":"git_reference **ref_out, git_repository *repo, const char *name, const char *target","comments":["/**","* Create a new symbolic reference.","*","* The reference will be created in the repository and written","* to the disk.","*","* This reference is owned by the repository and shall not","* be free'd by the user.","*","* @param ref_out Pointer to the newly created reference","* @param repo Repository where that reference will live","* @param name The name of the reference","* @param target The target of the reference","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_create_symbolic_f","line":71,"args":"git_reference **ref_out, git_repository *repo, const char *name, const char *target","comments":["/**","* Create a new symbolic reference, overwriting an existing one with","* the same name, if it exists.","*","* If the new reference isn't a symbolic one, any pointers to the old","* reference become invalid.","*","* The reference will be created in the repository and written","* to the disk.","*","* This reference is owned by the repository and shall not","* be free'd by the user.","*","* @param ref_out Pointer to the newly created reference","* @param repo Repository where that reference will live","* @param name The name of the reference","* @param target The target of the reference","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_create_oid","line":92,"args":"git_reference **ref_out, git_repository *repo, const char *name, const git_oid *id","comments":["/**","* Create a new object id reference.","*","* The reference will be created in the repository and written","* to the disk.","*","* This reference is owned by the repository and shall not","* be free'd by the user.","*","* @param ref_out Pointer to the newly created reference","* @param repo Repository where that reference will live","* @param name The name of the reference","* @param id The object id pointed to by the reference.","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_create_oid_f","line":109,"args":"git_reference **ref_out, git_repository *repo, const char *name, const git_oid *id","comments":["/**","* Create a new object id reference, overwriting an existing one with","* the same name, if it exists.","*","* If the new reference isn't an object id one, any pointers to the","* old reference become invalid.","*","* The reference will be created in the repository and written","* to the disk.","*","* This reference is owned by the repository and shall not","* be free'd by the user.","*","* @param ref_out Pointer to the newly created reference","* @param repo Repository where that reference will live","* @param name The name of the reference","* @param id The object id pointed to by the reference.","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(const git_oid *)","function":"git_reference_oid","line":130,"args":"git_reference *ref","comments":["/**","* Get the OID pointed to by a reference.","*","* Only available if the reference is direct (i.e. not symbolic)","*","* @param ref The reference","* @return a pointer to the oid if available, NULL otherwise","*/"]},{"return":"GIT_EXTERN(const char *)","function":"git_reference_target","line":140,"args":"git_reference *ref","comments":["/**","* Get full name to the reference pointed by this reference","*","* Only available if the reference is symbolic","*","* @param ref The reference","* @return a pointer to the name if available, NULL otherwise","*/"]},{"return":"GIT_EXTERN(git_rtype)","function":"git_reference_type","line":150,"args":"git_reference *ref","comments":["/**","* Get the type of a reference","*","* Either direct (GIT_REF_OID) or symbolic (GIT_REF_SYMBOLIC)","*","* @param ref The reference","* @return the type","*/"]},{"return":"GIT_EXTERN(const char *)","function":"git_reference_name","line":160,"args":"git_reference *ref","comments":["/**","* Get the full name of a reference","*","* @param ref The reference","* @return the full name for the ref","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_resolve","line":168,"args":"git_reference **resolved_ref, git_reference *ref","comments":["/**","* Resolve a symbolic reference","*","* Thie method iteratively peels a symbolic reference","* until it resolves to a direct reference to an OID.","*","* If a direct reference is passed as an argument,","* that reference is returned immediately","*","* @param resolved_ref Pointer to the peeled reference","* @param ref The reference","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(git_repository *)","function":"git_reference_owner","line":183,"args":"git_reference *ref","comments":["/**","* Get the repository where a reference resides","*","* @param ref The reference","* @return a pointer to the repo","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_set_target","line":191,"args":"git_reference *ref, const char *target","comments":["/**","* Set the symbolic target of a reference.","*","* The reference must be a symbolic reference, otherwise","* this method will fail.","*","* The reference will be automatically updated in","* memory and on disk.","*","* @param ref The reference","* @param target The new target for the reference","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_set_oid","line":206,"args":"git_reference *ref, const git_oid *id","comments":["/**","* Set the OID target of a reference.","*","* The reference must be a direct reference, otherwise","* this method will fail.","*","* The reference will be automatically updated in","* memory and on disk.","*","* @param ref The reference","* @param target The new target OID for the reference","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_rename","line":221,"args":"git_reference *ref, const char *new_name","comments":["/**","* Rename an existing reference","*","* This method works for both direct and symbolic references.","* The new name will be checked for validity and may be","* modified into a normalized form.","*","* The refernece will be immediately renamed in-memory","* and on disk.","*","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_rename_f","line":234,"args":"git_reference *ref, const char *new_name","comments":["/**","* Rename an existing reference, overwriting an existing one with the","* same name, if it exists.","*","* This method works for both direct and symbolic references.","* The new name will be checked for validity and may be","* modified into a normalized form.","*","* The refernece will be immediately renamed in-memory","* and on disk.","*","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_delete","line":248,"args":"git_reference *ref","comments":["/**","* Delete an existing reference","*","* This method works for both direct and symbolic references.","*","* The reference will be immediately removed on disk and from","* memory. The given reference pointer will no longer be valid.","*","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_packall","line":259,"args":"git_repository *repo","comments":["/**","* Pack all the loose references in the repository","*","* This method will load into the cache all the loose","* references on the repository and update the","* `packed-refs` file with them.","*","* Once the `packed-refs` file has been written properly,","* the loose references will be removed from disk.","*","* WARNING: calling this method may invalidate any existing","* references previously loaded on the cache.","*","* @param repo Repository where the loose refs will be packed","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_listall","line":277,"args":"git_strarray *array, git_repository *repo, unsigned int list_flags","comments":["/**","* Fill a list with all the references that can be found","* in a repository.","*","* The listed references may be filtered by type, or using","* a bitwise OR of several types. Use the magic value","* `GIT_REF_LISTALL` to obtain all references, including","* packed ones.","*","* The string array will be filled with the names of all","* references; these values are owned by the user and","* should be free'd manually when no longer needed, using","* `git_strarray_free`.","*","* @param array Pointer to a git_strarray structure where","*\t\tthe reference names will be stored","* @param repo Repository where to find the refs","* @param list_flags Filtering flags for the reference","*\t\tlisting.","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_reference_listcb","line":301,"args":"git_repository *repo, unsigned int list_flags, int (*callback)(const char *, void *), void *payload","comments":["/**","* List all the references in the repository, calling a custom","* callback for each one.","*","* The listed references may be filtered by type, or using","* a bitwise OR of several types. Use the magic value","* `GIT_REF_LISTALL` to obtain all references, including","* packed ones.","*","* The `callback` function will be called for each of the references","* in the repository, and will receive the name of the reference and","* the `payload` value passed to this method.","*","* @param repo Repository where to find the refs","* @param list_flags Filtering flags for the reference","*\t\tlisting.","* @param callback Function which will be called for every listed ref","* @param payload Additional data to pass to the callback","* @return 0 on success; error code otherwise","*/"]}]},"oid.h":{"meta":{"brief":"Git object id routines","defgroup":"git_oid Git object id routines","file":"git2/oid.h","ingroup":"Git"},"functions":[{"return":"GIT_EXTERN(int)","function":"git_oid_mkstr","line":52,"args":"git_oid *out, const char *str","comments":["/**","* Parse a hex formatted object id into a git_oid.","* @param out oid structure the result is written into.","* @param str input hex string; must be pointing at the start of","*        the hex sequence and have at least the number of bytes","*        needed for an oid encoded in hex (40 bytes).","* @return GIT_SUCCESS if valid; GIT_ENOTOID on failure.","*/"]},{"return":"GIT_EXTERN(void)","function":"git_oid_mkraw","line":62,"args":"git_oid *out, const unsigned char *raw","comments":["/**","* Copy an already raw oid into a git_oid structure.","* @param out oid structure the result is written into.","* @param raw the raw input bytes to be copied.","*/"]},{"return":"GIT_EXTERN(void)","function":"git_oid_fmt","line":69,"args":"char *str, const git_oid *oid","comments":["/**","* Format a git_oid into a hex string.","* @param str output hex string; must be pointing at the start of","*        the hex sequence and have at least the number of bytes","*        needed for an oid encoded in hex (40 bytes).  Only the","*        oid digits are written; a '\\\\0' terminator must be added","*        by the caller if it is required.","* @param oid oid structure to format.","*/"]},{"return":"GIT_EXTERN(void)","function":"git_oid_pathfmt","line":80,"args":"char *str, const git_oid *oid","comments":["/**","* Format a git_oid into a loose-object path string.","* <p>","* The resulting string is \"aa/...\", where \"aa\" is the first two","* hex digitis of the oid and \"...\" is the remaining 38 digits.","*","* @param str output hex string; must be pointing at the start of","*        the hex sequence and have at least the number of bytes","*        needed for an oid encoded in hex (41 bytes).  Only the","*        oid digits are written; a '\\\\0' terminator must be added","*        by the caller if it is required.","* @param oid oid structure to format.","*/"]},{"return":"GIT_EXTERN(char *)","function":"git_oid_allocfmt","line":95,"args":"const git_oid *oid","comments":["/**","* Format a gid_oid into a newly allocated c-string.","* @param oid the oid structure to format","* @return the c-string; NULL if memory is exhausted.  Caller must","*         deallocate the string with free().","*/"]},{"return":"GIT_EXTERN(char *)","function":"git_oid_to_string","line":103,"args":"char *out, size_t n, const git_oid *oid","comments":["/**","* Format a git_oid into a buffer as a hex format c-string.","* <p>","* If the buffer is smaller than GIT_OID_HEXSZ+1, then the resulting","* oid c-string will be truncated to n-1 characters. If there are","* any input parameter errors (out == NULL, n == 0, oid == NULL),","* then a pointer to an empty string is returned, so that the return","* value can always be printed.","*","* @param out the buffer into which the oid string is output.","* @param n the size of the out buffer.","* @param oid the oid structure to format.","* @return the out buffer pointer, assuming no input parameter","*         errors, otherwise a pointer to an empty string.","*/"]},{"return":"GIT_EXTERN(void)","function":"git_oid_cpy","line":120,"args":"git_oid *out, const git_oid *src","comments":["/**","* Copy an oid from one structure to another.","* @param out oid structure the result is written into.","* @param src oid structure to copy from.","*/"]},{"return":"GIT_EXTERN(int)","function":"git_oid_cmp","line":127,"args":"const git_oid *a, const git_oid *b","comments":["/**","* Compare two oid structures.","* @param a first oid structure.","* @param b second oid structure.","* @return <0, 0, >0 if a < b, a == b, a > b.","*/"]},{"return":"int","function":"git_oid_shorten_add","line":156,"args":"git_oid_shorten *os, const char *text_oid","comments":["/**","* Add a new OID to set of shortened OIDs and calculate","* the minimal length to uniquely identify all the OIDs in","* the set.","*","* The OID is expected to be a 40-char hexadecimal string.","* The OID is owned by the user and will not be modified","* or freed.","*","* For performance reasons, there is a hard-limit of how many","* OIDs can be added to a single set (around ~22000, assuming","* a mostly randomized distribution), which should be enough","* for any kind of program, and keeps the algorithm fast and","* memory-efficient.","*","* Attempting to add more than those OIDs will result in a","* GIT_ENOMEM error","*","* @param os a `git_oid_shorten` instance","* @param text_oid an OID in text form","* @return the minimal length to uniquely identify all OIDs","*\t\tadded so far to the set; or an error code (<0) if an","*\t\terror occurs.","*/"]},{"return":"void","function":"git_oid_shorten_free","line":182,"args":"git_oid_shorten *os","comments":["/**","* Free an OID shortener instance","*","* @param os a `git_oid_shorten` instance","*/"]}]},"object.h":{"meta":{"brief":"Git revision object management routines","defgroup":"git_object Git revision object management routines","file":"git2/object.h","ingroup":"Git"},"functions":[{"return":"GIT_EXTERN(int)","function":"git_object_lookup","line":41,"args":"git_object **object, git_repository *repo, const git_oid *id, git_otype type","comments":["/**","* Lookup a reference to one of the objects in a repostory.","*","* The generated reference is owned by the repository and","* should be closed with the `git_object_close` method","* instead of free'd manually.","*","* The 'type' parameter must match the type of the object","* in the odb; the method will fail otherwise.","* The special value 'GIT_OBJ_ANY' may be passed to let","* the method guess the object's type.","*","* @param object pointer to the looked-up object","* @param repo the repository to look up the object","* @param id the unique identifier for the object","* @param type the type of the object","* @return a reference to the object","*/"]},{"return":"GIT_EXTERN(const git_oid *)","function":"git_object_id","line":61,"args":"const git_object *obj","comments":["/**","* Get the id (SHA1) of a repository object","*","* @param obj the repository object","* @return the SHA1 id","*/"]},{"return":"GIT_EXTERN(git_otype)","function":"git_object_type","line":69,"args":"const git_object *obj","comments":["/**","* Get the object type of an object","*","* @param obj the repository object","* @return the object's type","*/"]},{"return":"GIT_EXTERN(git_repository *)","function":"git_object_owner","line":77,"args":"const git_object *obj","comments":["/**","* Get the repository that owns this object","*","* @param obj the object","* @return the repository who owns this object","*/"]},{"return":"GIT_EXTERN(void)","function":"git_object_close","line":85,"args":"git_object *object","comments":["/**","* Close an open object","*","* This method instructs the library to close an existing","* object; note that git_objects are owned and cached by the repository","* so the object may or may not be freed after this library call,","* depending on how agressive is the caching mechanism used","* by the repository.","*","* IMPORTANT:","* It *is* necessary to call this method when you stop using","* an object. Failure to do so will cause a memory leak.","*","* @param object the object to close","*/"]},{"return":"GIT_EXTERN(int)","function":"git_object_typeisloose","line":121,"args":"git_otype type","comments":["/**","* Determine if the given git_otype is a valid loose object type.","*","* @param type object type to test.","* @return true if the type represents a valid loose object type,","* false otherwise.","*/"]},{"return":"GIT_EXTERN(size_t)","function":"git_object__size","line":130,"args":"git_otype type","comments":["/**","* Get the size in bytes for the structure which","* acts as an in-memory representation of any given","* object type.","*","* For all the core types, this would the equivalent","* of calling `sizeof(git_commit)` if the core types","* were not opaque on the external API.","*","* @param type object type to get its size","* @return size in bytes of the object","*/"]}]},"common.h":{"meta":{"brief":"Git common platform definitions","defgroup":"git_common Git common platform definitions","file":"git2/common.h","ingroup":"Git"},"functions":[]},"blob.h":{"meta":{"brief":"Git blob load and write routines","defgroup":"git_blob Git blob load and write routines","file":"git2/blob.h","ingroup":"Git"},"functions":[{"return":"GIT_INLINE(int)","function":"git_blob_lookup","line":42,"args":"git_blob **blob, git_repository *repo, const git_oid *id","comments":["/**","* Lookup a blob object from a repository.","*","* @param blob pointer to the looked up blob","* @param repo the repo to use when locating the blob.","* @param id identity of the blob to locate.","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_INLINE(void)","function":"git_blob_close","line":55,"args":"git_blob *blob","comments":["/**","* Close an open blob","*","* This is a wrapper around git_object_close()","*","* IMPORTANT:","* It *is* necessary to call this method when you stop","* using a blob. Failure to do so will cause a memory leak.","*","* @param blob the blob to close","*/"]},{"return":"GIT_EXTERN(const void *)","function":"git_blob_rawcontent","line":73,"args":"git_blob *blob","comments":["/**","* Get a read-only buffer with the raw content of a blob.","*","* A pointer to the raw content of a blob is returned;","* this pointer is owned internally by the object and shall","* not be free'd. The pointer may be invalidated at a later","* time.","*","* @param blob pointer to the blob","* @return the pointer; NULL if the blob has no contents","*/"]},{"return":"GIT_EXTERN(int)","function":"git_blob_rawsize","line":86,"args":"git_blob *blob","comments":["/**","* Get the size in bytes of the contents of a blob","*","* @param blob pointer to the blob","* @return size on bytes","*/"]},{"return":"GIT_EXTERN(int)","function":"git_blob_create_fromfile","line":94,"args":"git_oid *oid, git_repository *repo, const char *path","comments":["/**","* Read a file from the working folder of a repository","* and write it to the Object Database as a loose blob","*","* @param oid return the id of the written blob","* @param repo repository where the blob will be written.","*\tthis repository cannot be bare","* @param path file from which the blob will be created,","*\trelative to the repository's working dir","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_blob_create_frombuffer","line":108,"args":"git_oid *oid, git_repository *repo, const void *buffer, size_t len","comments":["/**","* Write an in-memory buffer to the ODB as a blob","*","* @param oid return the oid of the written blob","* @param repo repository where to blob will be written","* @param buffer data to be written into the blob","* @param len length of the data","* @return 0 on success; error code otherwise","*/"]}]},"repository.h":{"meta":{"brief":"Git repository management routines","defgroup":"git_repository Git repository management routines","file":"git2/repository.h","ingroup":"Git"},"functions":[{"return":"GIT_EXTERN(int)","function":"git_repository_open","line":41,"args":"git_repository **repository, const char *path","comments":["/**","* Open a git repository.","*","* The 'path' argument must point to an existing git repository","* folder, e.g.","*","*\t\t/path/to/my_repo/.git/\t(normal repository)","*\t\t\t\t\t\t\tobjects/","*\t\t\t\t\t\t\tindex","*\t\t\t\t\t\t\tHEAD","*","*\t\t/path/to/bare_repo/\t\t(bare repository)","*\t\t\t\t\t\tobjects/","*\t\t\t\t\t\tindex","*\t\t\t\t\t\tHEAD","*","*\tThe method will automatically detect if 'path' is a normal","*\tor bare repository or fail is 'path' is neither.","*","* @param repository pointer to the repo which will be opened","* @param path the path to the repository","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(git_odb *)","function":"git_repository_database","line":135,"args":"git_repository *repo","comments":["/**","* Get the object database behind a Git repository","*","* @param repo a repository object","* @return a pointer to the object db","*/"]},{"return":"GIT_EXTERN(int)","function":"git_repository_index","line":143,"args":"git_index **index, git_repository *repo","comments":["/**","* Get the Index file of a Git repository","*","* This is a cheap operation; the index is only opened on the first call,","* and subsequent calls only retrieve the previous pointer.","*","* @param index Pointer where to store the index","* @param repo a repository object","* @return 0 on success; error code if the index could not be opened","*/"]},{"return":"GIT_EXTERN(void)","function":"git_repository_free","line":155,"args":"git_repository *repo","comments":["/**","* Free a previously allocated repository","*","* Note that after a repository is free'd, all the objects it has spawned","* will still exist until they are manually closed by the user","* with `git_object_close`, but accessing any of the attributes of","* an object without a backing repository will result in undefined","* behavior","*","* @param repo repository handle to close. If NULL nothing occurs.","*/"]},{"return":"GIT_EXTERN(int)","function":"git_repository_init","line":168,"args":"git_repository **repo_out, const char *path, unsigned is_bare","comments":["/**","* Creates a new Git repository in the given folder.","*","* TODO:","*\t- Reinit the repository","*\t- Create config files","*","* @param repo_out pointer to the repo which will be created or reinitialized","* @param path the path to the repository","* @param is_bare if true, a Git repository without a working directory is created","*\t\tat the pointed path. If false, provided path will be considered as the working","*\t\tdirectory into which the .git directory will be created.","*","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_repository_is_empty","line":185,"args":"git_repository *repo","comments":["/**","* Check if a repository is empty","*","* An empty repository has just been initialized and contains","* no commits.","*","* @param repo Repo to test","* @return 1 if the repository is empty, 0 if it isn't, error code","* if the repository is corrupted","*/"]},{"return":"GIT_EXTERN(const char *)","function":"git_repository_path","line":197,"args":"git_repository *repo","comments":["/**","* Get the normalized path to the git repository.","*","* @param repo a repository object","* @return absolute path to the git directory","*/"]},{"return":"GIT_EXTERN(const char *)","function":"git_repository_workdir","line":205,"args":"git_repository *repo","comments":["/**","* Get the normalized path to the working directory of the repository.","*","* If the repository is bare, there is no working directory and NULL we be returned.","*","* @param repo a repository object","* @return NULL if the repository is bare; absolute path to the working directory otherwise.","*/"]}]},"odb_backend.h":{"meta":{"brief":"Git custom backend functions","defgroup":"git_backend Git custom backend API","file":"git2/backend.h","ingroup":"Git"},"functions":[]},"commit.h":{"meta":{"brief":"Git commit parsing, formatting routines","defgroup":"git_commit Git commit parsing, formatting routines","file":"git2/commit.h","ingroup":"Git"},"functions":[{"return":"GIT_INLINE(int)","function":"git_commit_lookup","line":42,"args":"git_commit **commit, git_repository *repo, const git_oid *id","comments":["/**","* Lookup a commit object from a repository.","*","* @param commit pointer to the looked up commit","* @param repo the repo to use when locating the commit.","* @param id identity of the commit to locate.  If the object is","*        an annotated tag it will be peeled back to the commit.","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_INLINE(void)","function":"git_commit_close","line":56,"args":"git_commit *commit","comments":["/**","* Close an open commit","*","* This is a wrapper around git_object_close()","*","* IMPORTANT:","* It *is* necessary to call this method when you stop","* using a commit. Failure to do so will cause a memory leak.","*","* @param commit the commit to close","*/"]},{"return":"GIT_EXTERN(const git_oid *)","function":"git_commit_id","line":73,"args":"git_commit *commit","comments":["/**","* Get the id of a commit.","*","* @param commit a previously loaded commit.","* @return object identity for the commit.","*/"]},{"return":"GIT_EXTERN(const char *)","function":"git_commit_message_short","line":81,"args":"git_commit *commit","comments":["/**","* Get the short (one line) message of a commit.","*","* @param commit a previously loaded commit.","* @return the short message of a commit","*/"]},{"return":"GIT_EXTERN(const char *)","function":"git_commit_message","line":89,"args":"git_commit *commit","comments":["/**","* Get the full message of a commit.","*","* @param commit a previously loaded commit.","* @return the message of a commit","*/"]},{"return":"GIT_EXTERN(git_time_t)","function":"git_commit_time","line":97,"args":"git_commit *commit","comments":["/**","* Get the commit time (i.e. committer time) of a commit.","*","* @param commit a previously loaded commit.","* @return the time of a commit","*/"]},{"return":"GIT_EXTERN(int)","function":"git_commit_time_offset","line":105,"args":"git_commit *commit","comments":["/**","* Get the commit timezone offset (i.e. committer's preferred timezone) of a commit.","*","* @param commit a previously loaded commit.","* @return positive or negative timezone offset, in minutes from UTC","*/"]},{"return":"GIT_EXTERN(const git_signature *)","function":"git_commit_committer","line":113,"args":"git_commit *commit","comments":["/**","* Get the committer of a commit.","*","* @param commit a previously loaded commit.","* @return the committer of a commit","*/"]},{"return":"GIT_EXTERN(const git_signature *)","function":"git_commit_author","line":121,"args":"git_commit *commit","comments":["/**","* Get the author of a commit.","*","* @param commit a previously loaded commit.","* @return the author of a commit","*/"]},{"return":"GIT_EXTERN(int)","function":"git_commit_tree","line":129,"args":"git_tree **tree_out, git_commit *commit","comments":["/**","* Get the tree pointed to by a commit.","*","* @param tree_out pointer where to store the tree object","* @param commit a previously loaded commit.","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(const git_oid *)","function":"git_commit_tree_oid","line":138,"args":"git_commit *commit","comments":["/**","* Get the id of the tree pointed to by a commit. This differs from","* `git_commit_tree` in that no attempts are made to fetch an object","* from the ODB.","*","* @param commit a previously loaded commit.","* @return the id of tree pointed to by commit.","*/"]},{"return":"GIT_EXTERN(unsigned int)","function":"git_commit_parentcount","line":148,"args":"git_commit *commit","comments":["/**","* Get the number of parents of this commit","*","* @param commit a previously loaded commit.","* @return integer of count of parents","*/"]},{"return":"GIT_EXTERN(int)","function":"git_commit_parent","line":156,"args":"git_commit **parent, git_commit *commit, unsigned int n","comments":["/**","* Get the specified parent of the commit.","*","* @param parent Pointer where to store the parent commit","* @param commit a previously loaded commit.","* @param n the position of the parent (from 0 to `parentcount`)","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(const git_oid *)","function":"git_commit_parent_oid","line":166,"args":"git_commit *commit, unsigned int n","comments":["/**","* Get the oid of a specified parent for a commit. This is different from","* `git_commit_parent`, which will attempt to load the parent commit from","* the ODB.","*","* @param commit a previously loaded commit.","* @param n the position of the parent (from 0 to `parentcount`)","* @return the id of the parent, NULL on error.","*/"]}]},"errors.h":{"meta":{"brief":"Git error handling routines and variables","defgroup":null,"file":"git2/errors.h","ingroup":"Git"},"functions":[{"return":"GIT_EXTERN(const char *)","function":"git_lasterror","line":128,"args":"void","comments":["/**","* Return a detailed error string with the latest error","* that occurred in the library.","* @return a string explaining the error","*/"]},{"return":"GIT_EXTERN(const char *)","function":"git_strerror","line":135,"args":"int num","comments":["/**","* strerror() for the Git library","*","* Get a string description for a given error code.","* NOTE: This method will be eventually deprecated in favor","* of the new `git_lasterror`.","*","* @param num The error code to explain","* @return a string explaining the error code","*/"]}]},"thread-utils.h":{"meta":{"brief":null,"defgroup":null,"file":null,"ingroup":null},"functions":[]},"revwalk.h":{"meta":{"brief":"Git revision traversal routines","defgroup":"git_revwalk Git revision traversal routines","file":"git2/revwalk.h","ingroup":"Git"},"functions":[{"return":"GIT_EXTERN(int)","function":"git_revwalk_new","line":70,"args":"git_revwalk **walker, git_repository *repo","comments":["/**","* Allocate a new revision walker to iterate through a repo.","*","* This revision walker uses a custom memory pool and an internal","* commit cache, so it is relatively expensive to allocate.","*","* For maximum performance, this revision walker should be","* reused for different walks.","*","* This revision walker is *not* thread safe: it may only be","* used to walk a repository on a single thread; however,","* it is possible to have several revision walkers in","* several different threads walking the same repository.","*","* @param walker pointer to the new revision walker","* @param repo the repo to walk through","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(void)","function":"git_revwalk_reset","line":90,"args":"git_revwalk *walker","comments":["/**","* Reset the revision walker for reuse.","*","* This will clear all the pushed and hidden commits, and","* leave the walker in a blank state (just like at","* creation) ready to receive new commit pushes and","* start a new walk.","*","* The revision walk is automatically reset when a walk","* is over.","*","* @param walker handle to reset.","*/"]},{"return":"GIT_EXTERN(int)","function":"git_revwalk_push","line":105,"args":"git_revwalk *walk, const git_oid *oid","comments":["/**","* Mark a commit to start traversal from.","*","* The given OID must belong to a commit on the walked","* repository.","*","* The given commit will be used as one of the roots","* when starting the revision walk. At least one commit","* must be pushed the repository before a walk can","* be started.","*","* @param walker the walker being used for the traversal.","* @param oid the oid of the commit to start from.","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_revwalk_hide","line":123,"args":"git_revwalk *walk, const git_oid *oid","comments":["/**","* Mark a commit (and its ancestors) uninteresting for the output.","*","* The given OID must belong to a commit on the walked","* repository.","*","* The resolved commit and all its parents will be hidden from the","* output on the revision walk.","*","* @param walker the walker being used for the traversal.","* @param commit the commit that will be ignored during the traversal","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_revwalk_next","line":138,"args":"git_oid *oid, git_revwalk *walk","comments":["/**","* Get the next commit from the revision walk.","*","* The initial call to this method is *not* blocking when","* iterating through a repo with a time-sorting mode.","*","* Iterating with Topological or inverted modes makes the initial","* call blocking to preprocess the commit list, but this block should be","* mostly unnoticeable on most repositories (topological preprocessing","* times at 0.3s on the git.git repo).","*","* The revision walker is reset when the walk is over.","*","* @param oid Pointer where to store the oid of the next commit","* @param walk the walker to pop the commit from.","* @return GIT_SUCCESS if the next commit was found;","*\tGIT_EREVWALKOVER if there are no commits left to iterate","*/"]},{"return":"GIT_EXTERN(void)","function":"git_revwalk_sorting","line":158,"args":"git_revwalk *walk, unsigned int sort_mode","comments":["/**","* Change the sorting mode when iterating through the","* repository's contents.","*","* Changing the sorting mode resets the walker.","*","* @param walk the walker being used for the traversal.","* @param sort_mode combination of GIT_SORT_XXX flags","*/"]},{"return":"GIT_EXTERN(void)","function":"git_revwalk_free","line":169,"args":"git_revwalk *walk","comments":["/**","* Free a revision walker previously allocated.","*","* @param walk traversal handle to close.  If NULL nothing occurs.","*/"]},{"return":"GIT_EXTERN(git_repository *)","function":"git_revwalk_repository","line":176,"args":"git_revwalk *walk","comments":["/**","* Return the repository on which this walker","* is operating.","*","* @param walk the revision walker","* @return the repository being walked","*/"]}]},"index.h":{"meta":{"brief":"Git index parsing and manipulation routines","defgroup":"git_index Git index parsing and manipulation routines","file":"git2/index.h","ingroup":"Git"},"functions":[{"return":"GIT_EXTERN(int)","function":"git_index_open_bare","line":105,"args":"git_index **index, const char *index_path","comments":["/**","* Create a new Git index object as a memory representation","* of the Git index file in 'index_path', without a repository","* to back it.","*","* Since there is no ODB behind this index, any Index methods","* which rely on the ODB (e.g. index_add) will fail with the","* GIT_EBAREINDEX error code.","*","* @param index the pointer for the new index","* @param index_path the path to the index file in disk","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_index_open_inrepo","line":120,"args":"git_index **index, git_repository *repo","comments":["/**","* Open the Index inside the git repository pointed","* by 'repo'.","*","* @param index the pointer for the new index","* @param repo the git repo which owns the index","* @return 0 on success; error code otherwise","*/"]},{"return":"GIT_EXTERN(void)","function":"git_index_clear","line":130,"args":"git_index *index","comments":["/**","* Clear the contents (all the entries) of an index object.","* This clears the index object in memory; changes must be manually","* written to disk for them to take effect.","*","* @param index an existing index object","*/"]},{"return":"GIT_EXTERN(void)","function":"git_index_free","line":139,"args":"git_index *index","comments":["/**","* Free an existing index object.","*","* @param index an existing index object","*/"]},{"return":"GIT_EXTERN(int)","function":"git_index_read","line":146,"args":"git_index *index","comments":["/**","* Update the contents of an existing index object in memory","* by reading from the hard disk.","*","* @param index an existing index object","* @return 0 on success, otherwise an error code","*/"]},{"return":"GIT_EXTERN(int)","function":"git_index_write","line":155,"args":"git_index *index","comments":["/**","* Write an existing index object from memory back to disk","* using an atomic file lock.","*","* @param index an existing index object","* @return 0 on success, otherwise an error code","*/"]},{"return":"GIT_EXTERN(int)","function":"git_index_find","line":164,"args":"git_index *index, const char *path","comments":["/**","* Find the first index of any entries which point to given","* path in the Git index.","*","* @param index an existing index object","* @param path path to search","* @return an index >= 0 if found, -1 otherwise","*/"]},{"return":"GIT_EXTERN(int)","function":"git_index_add","line":174,"args":"git_index *index, const char *path, int stage","comments":["/**","* Add or update an index entry from a file in disk","*","* The file `path` must be relative to the repository's","* working folder and must be readable.","*","* This method will fail in bare index instances.","*","* @param index an existing index object","* @param path filename to add","* @param stage stage for the entry","* @return 0 on success, otherwise an error code","*/"]},{"return":"GIT_EXTERN(int)","function":"git_index_append","line":201,"args":"git_index *index, const char *path, int stage","comments":["/**","* Add (append) an index entry from a file in disk","*","* A new entry will always be inserted into the index;","* if the index already contains an entry for such","* path, the old entry will **not** be replaced.","*","* The file `path` must be relative to the repository's","* working folder and must be readable.","*","* This method will fail in bare index instances.","*","* @param index an existing index object","* @param path filename to add","* @param stage stage for the entry","* @return 0 on success, otherwise an error code","*/"]},{"return":"GIT_EXTERN(int)","function":"git_index_remove","line":237,"args":"git_index *index, int position","comments":["/**","* Remove an entry from the index","*","* @param index an existing index object","* @param position position of the entry to remove","* @return 0 on success, otherwise an error code","*/"]},{"return":"GIT_EXTERN(git_index_entry *)","function":"git_index_get","line":247,"args":"git_index *index, int n","comments":["/**","* Get a pointer to one of the entries in the index","*","* This entry can be modified, and the changes will be written","* back to disk on the next write() call.","*","* @param index an existing index object","* @param n the position of the entry","* @return a pointer to the entry; NULL if out of bounds","*/"]},{"return":"GIT_EXTERN(unsigned int)","function":"git_index_entrycount","line":259,"args":"git_index *index","comments":["/**","* Get the count of entries currently in the index","*","* @param index an existing index object","* @return integer of count of current entries","*/"]}]}}