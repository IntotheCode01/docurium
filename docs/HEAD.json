{"files":[{"lines":121,"file":"blob.h","meta":{"file":"git2/blob.h","brief":"Git blob load and write routines","defgroup":"git_blob Git blob load and write routines","ingroup":"Git"},"functions":["git_blob_lookup","git_blob_close","git_blob_rawcontent","git_blob_rawsize","git_blob_create_fromfile","git_blob_create_frombuffer"]},{"lines":302,"file":"commit.h","meta":{"file":"git2/commit.h","brief":"Git commit parsing, formatting routines","defgroup":"git_commit Git commit parsing, formatting routines","ingroup":"Git"},"functions":["git_commit_lookup","git_commit_close","git_commit_id","git_commit_message_short","git_commit_message","git_commit_time","git_commit_time_offset","git_commit_committer","git_commit_author","git_commit_tree","git_commit_tree_oid","git_commit_parentcount","git_commit_parent","git_commit_parent_oid"]},{"lines":98,"file":"common.h","meta":{"file":"git2/common.h","brief":"Git common platform definitions","defgroup":"git_common Git common platform definitions","ingroup":"Git"},"functions":[]},{"lines":149,"file":"errors.h","meta":{"file":"git2/errors.h","brief":"Git error handling routines and variables","defgroup":null,"ingroup":"Git"},"functions":["git_lasterror","git_strerror"]},{"lines":270,"file":"index.h","meta":{"file":"git2/index.h","brief":"Git index parsing and manipulation routines","defgroup":"git_index Git index parsing and manipulation routines","ingroup":"Git"},"functions":["git_index_open_bare","git_index_open_inrepo","git_index_clear","git_index_free","git_index_read","git_index_write","git_index_find","git_index_add","git_index_append","git_index_remove","git_index_get","git_index_entrycount"]},{"lines":147,"file":"object.h","meta":{"file":"git2/object.h","brief":"Git revision object management routines","defgroup":"git_object Git revision object management routines","ingroup":"Git"},"functions":["git_object_lookup","git_object_id","git_object_type","git_object_owner","git_object_close","git_object_typeisloose","git_object__size"]},{"lines":302,"file":"odb.h","meta":{"file":"git2/odb.h","brief":"Git object database routines","defgroup":"git_odb Git object database routines","ingroup":"Git"},"functions":["git_odb_new","git_odb_open","git_odb_add_backend","git_odb_add_alternate","git_odb_close","git_odb_read","git_odb_read_header","git_odb_exists","git_odb_write","git_odb_open_wstream","git_odb_open_rstream","git_odb_hash","git_odb_object_close","git_odb_object_id","git_odb_object_data","git_odb_object_size","git_odb_object_type"]},{"lines":107,"file":"odb_backend.h","meta":{"file":"git2/backend.h","brief":"Git custom backend functions","defgroup":"git_backend Git custom backend API","ingroup":"Git"},"functions":[]},{"lines":191,"file":"oid.h","meta":{"file":"git2/oid.h","brief":"Git object id routines","defgroup":"git_oid Git object id routines","ingroup":"Git"},"functions":["git_oid_mkstr","git_oid_mkraw","git_oid_fmt","git_oid_pathfmt","git_oid_allocfmt","git_oid_to_string","git_oid_cpy","git_oid_cmp","git_oid_shorten_add","git_oid_shorten_free"]},{"lines":325,"file":"refs.h","meta":{"file":"git2/refs.h","brief":"Git reference management routines","defgroup":"git_reference Git reference management routines","ingroup":"Git"},"functions":["git_reference_lookup","git_reference_create_symbolic","git_reference_create_symbolic_f","git_reference_create_oid","git_reference_create_oid_f","git_reference_oid","git_reference_target","git_reference_type","git_reference_name","git_reference_resolve","git_reference_owner","git_reference_set_target","git_reference_set_oid","git_reference_rename","git_reference_rename_f","git_reference_delete","git_reference_packall","git_reference_listall","git_reference_listcb"]},{"lines":217,"file":"repository.h","meta":{"file":"git2/repository.h","brief":"Git repository management routines","defgroup":"git_repository Git repository management routines","ingroup":"Git"},"functions":["git_repository_open","git_repository_database","git_repository_index","git_repository_free","git_repository_init","git_repository_is_empty","git_repository_path","git_repository_workdir"]},{"lines":187,"file":"revwalk.h","meta":{"file":"git2/revwalk.h","brief":"Git revision traversal routines","defgroup":"git_revwalk Git revision traversal routines","ingroup":"Git"},"functions":["git_revwalk_new","git_revwalk_reset","git_revwalk_push","git_revwalk_hide","git_revwalk_next","git_revwalk_sorting","git_revwalk_free","git_revwalk_repository"]},{"lines":81,"file":"signature.h","meta":{"file":"git2/signature.h","brief":"Git signature creation","defgroup":"git_signature Git signature creation","ingroup":"Git"},"functions":["git_signature_new","git_signature_now","git_signature_dup","git_signature_free"]},{"lines":297,"file":"tag.h","meta":{"file":"git2/tag.h","brief":"Git tag parsing routines","defgroup":"git_tag Git tag management","ingroup":"Git"},"functions":["git_tag_lookup","git_tag_close","git_tag_id","git_tag_target","git_tag_target_oid","git_tag_type","git_tag_name","git_tag_tagger","git_tag_message"]},{"lines":71,"file":"thread-utils.h","meta":{"file":null,"brief":null,"defgroup":null,"ingroup":null},"functions":[]},{"lines":266,"file":"tree.h","meta":{"file":"git2/tree.h","brief":"Git tree parsing, loading routines","defgroup":"git_tree Git tree parsing, loading routines","ingroup":"Git"},"functions":["git_tree_lookup","git_tree_close","git_tree_id","git_tree_entrycount","git_tree_entry_byname","git_tree_entry_byindex","git_tree_entry_attributes","git_tree_entry_name","git_tree_entry_id","git_tree_create_fromindex","git_treebuilder_create","git_treebuilder_clear","git_treebuilder_free","git_treebuilder_get","git_treebuilder_insert","git_treebuilder_remove","git_treebuilder_filter","git_treebuilder_write"]},{"lines":162,"file":"types.h","meta":{"file":"git2/types.h","brief":"libgit2 base & compatibility types","defgroup":null,"ingroup":"Git"},"functions":[]},{"lines":58,"file":"zlib.h","meta":{"file":"git2/zlib.h","brief":"Git data compression routines","defgroup":"git_zlib Git data compression routines","ingroup":"Git"},"functions":[]}],"groups":[["blob",["blob_rawcontent","blob_create_fromfile","blob_close","blob_lookup","blob_rawsize","blob_create_frombuffer"]],["commit",["commit_parentcount","commit_message","commit_time_offset","commit_time","commit_tree","commit_committer","commit_close","commit_parent","commit_id","commit_parent_oid","commit_author","commit_lookup","commit_message_short","commit_tree_oid"]],["index",["index_append","index_add","index_get","index_open_inrepo","index_clear","index_free","index_write","index_remove","index_find","index_read","index_open_bare","index_entrycount"]],["lasterror",["lasterror"]],["object",["object_typeisloose","object_id","object_lookup","object_type","object__size","object_owner","object_close"]],["odb",["odb_open","odb_add_alternate","odb_hash","odb_object_data","odb_close","odb_add_backend","odb_object_id","odb_new","odb_open_rstream","odb_exists","odb_read_header","odb_write","odb_open_wstream","odb_read","odb_object_type","odb_object_size","odb_object_close"]],["oid",["oid_mkstr","oid_cmp","oid_shorten_free","oid_cpy","oid_shorten_add","oid_allocfmt","oid_pathfmt","oid_fmt","oid_to_string","oid_mkraw"]],["reference",["reference_create_oid","reference_set_target","reference_type","reference_create_symbolic","reference_oid","reference_create_oid_f","reference_target","reference_lookup","reference_resolve","reference_name","reference_create_symbolic_f","reference_owner","reference_packall","reference_rename_f","reference_listall","reference_set_oid","reference_listcb","reference_delete","reference_rename"]],["repository",["repository_index","repository_database","repository_free","repository_init","repository_workdir","repository_open","repository_path","repository_is_empty"]],["revwalk",["revwalk_free","revwalk_new","revwalk_repository","revwalk_hide","revwalk_next","revwalk_push","revwalk_sorting","revwalk_reset"]],["signature",["signature_new","signature_dup","signature_now","signature_free"]],["strerror",["strerror"]],["tag",["tag_close","tag_name","tag_id","tag_target","tag_tagger","tag_message","tag_lookup","tag_target_oid","tag_type"]],["tree",["tree_entry_attributes","tree_lookup","tree_close","tree_entry_id","tree_entry_byname","tree_entrycount","tree_create_fromindex","tree_entry_byindex","tree_id","tree_entry_name"]],["treebuilder",["treebuilder_insert","treebuilder_write","treebuilder_create","treebuilder_filter","treebuilder_clear","treebuilder_get","treebuilder_remove","treebuilder_free"]]],"functions":{"git_treebuilder_insert":{"comments":["/**","* Add or update an entry to the builder","*","* Insert a new entry for `filename` in the builder with the","* given attributes.","*","* if an entry named `filename` already exists, its attributes","* will be updated with the given ones.","*","* The optional pointer `entry_out` can be used to retrieve a","* pointer to the newly created/updated entry.","*","* @param entry_out Pointer to store the entry (optional)","* @param bld Tree builder","* @param filename Filename of the entry","* @param id SHA1 oid of the entry","* @param attributes Folder attributes of the entry","* @return 0 on success; error code otherwise","*/"],"line":208,"args":"git_tree_entry **entry_out, git_treebuilder *bld, const char *filename, const git_oid *id, unsigned int attributes","return":"GIT_EXTERN(int)"},"git_tag_close":{"comments":["/**","* Close an open tag","*","* This is a wrapper around git_object_close()","*","* IMPORTANT:","* It *is* necessary to call this method when you stop","* using a tag. Failure to do so will cause a memory leak.","*","* @param tag the tag to close","*/"],"line":55,"args":"git_tag *tag","return":"GIT_INLINE(void)"},"git_treebuilder_write":{"comments":["/**","* Write the contents of the tree builder as a tree object","*","* The tree builder will be written to the given `repo`, and","* it's identifying SHA1 hash will be stored in the `oid`","* pointer.","*","* @param oid Pointer where to store the written OID","* @param repo Repository where to store the object","* @param bld Tree builder to write","* @return 0 on success; error code otherwise","*/"],"line":250,"args":"git_oid *oid, git_repository *repo, git_treebuilder *bld","return":"GIT_EXTERN(int)"},"git_tree_entry_attributes":{"comments":["/**","* Get the UNIX file attributes of a tree entry","*","* @param entry a tree entry","* @return attributes as an integer","*/"],"line":107,"args":"const git_tree_entry *entry","return":"GIT_EXTERN(unsigned int)"},"git_commit_parentcount":{"comments":["/**","* Get the number of parents of this commit","*","* @param commit a previously loaded commit.","* @return integer of count of parents","*/"],"line":148,"args":"git_commit *commit","return":"GIT_EXTERN(unsigned int)"},"git_oid_mkstr":{"comments":["/**","* Parse a hex formatted object id into a git_oid.","* @param out oid structure the result is written into.","* @param str input hex string; must be pointing at the start of","*        the hex sequence and have at least the number of bytes","*        needed for an oid encoded in hex (40 bytes).","* @return GIT_SUCCESS if valid; GIT_ENOTOID on failure.","*/"],"line":52,"args":"git_oid *out, const char *str","return":"GIT_EXTERN(int)"},"git_reference_create_oid":{"comments":["/**","* Create a new object id reference.","*","* The reference will be created in the repository and written","* to the disk.","*","* This reference is owned by the repository and shall not","* be free'd by the user.","*","* @param ref_out Pointer to the newly created reference","* @param repo Repository where that reference will live","* @param name The name of the reference","* @param id The object id pointed to by the reference.","* @return 0 on success; error code otherwise","*/"],"line":92,"args":"git_reference **ref_out, git_repository *repo, const char *name, const git_oid *id","return":"GIT_EXTERN(int)"},"git_tree_lookup":{"comments":["/**","* Lookup a tree object from the repository.","*","* @param tree pointer to the looked up tree","* @param repo the repo to use when locating the tree.","* @param id identity of the tree to locate.","* @return 0 on success; error code otherwise","*/"],"line":42,"args":"git_tree **tree, git_repository *repo, const git_oid *id","return":"GIT_INLINE(int)"},"git_odb_open":{"comments":["/**","* Create a new object database and automatically add","* the two default backends:","*","*\t- git_odb_backend_loose: read and write loose object files","*\t\tfrom disk, assuming `objects_dir` as the Objects folder","*","*\t- git_odb_backend_pack: read objects from packfiles,","*\t\tassuming `objects_dir` as the Objects folder which","*\t\tcontains a 'pack/' folder with the corresponding data","*","* @param out location to store the database pointer, if opened.","*            Set to NULL if the open failed.","* @param objects_dir path of the backends' \"objects\" directory.","* @return GIT_SUCCESS if the database opened; otherwise an error","*         code describing why the open was not possible.","*/"],"line":55,"args":"git_odb **out, const char *objects_dir","return":"GIT_EXTERN(int)"},"git_reference_set_target":{"comments":["/**","* Set the symbolic target of a reference.","*","* The reference must be a symbolic reference, otherwise","* this method will fail.","*","* The reference will be automatically updated in","* memory and on disk.","*","* @param ref The reference","* @param target The new target for the reference","* @return 0 on success; error code otherwise","*/"],"line":191,"args":"git_reference *ref, const char *target","return":"GIT_EXTERN(int)"},"git_commit_message":{"comments":["/**","* Get the full message of a commit.","*","* @param commit a previously loaded commit.","* @return the message of a commit","*/"],"line":89,"args":"git_commit *commit","return":"GIT_EXTERN(const char *)"},"git_treebuilder_create":{"comments":["/**","* Create a new tree builder.","*","* The tree builder can be used to create or modify","* trees in memory and write them as tree objects to the","* database.","*","* If the `source` parameter is not NULL, the tree builder","* will be initialized with the entries of the given tree.","*","* If the `source` parameter is NULL, the tree builder will","* have no entries and will have to be filled manually.","*","* @param builder_p Pointer where to store the tree builder","* @param source Source tree to initialize the builder (optional)","* @return 0 on sucess; error code otherwise","*/"],"line":159,"args":"git_treebuilder **builder_p, const git_tree *source","return":"GIT_EXTERN(int)"},"git_commit_time_offset":{"comments":["/**","* Get the commit timezone offset (i.e. committer's preferred timezone) of a commit.","*","* @param commit a previously loaded commit.","* @return positive or negative timezone offset, in minutes from UTC","*/"],"line":105,"args":"git_commit *commit","return":"GIT_EXTERN(int)"},"git_revwalk_free":{"comments":["/**","* Free a revision walker previously allocated.","*","* @param walk traversal handle to close.  If NULL nothing occurs.","*/"],"line":169,"args":"git_revwalk *walk","return":"GIT_EXTERN(void)"},"git_tree_close":{"comments":["/**","* Close an open tree","*","* This is a wrapper around git_object_close()","*","* IMPORTANT:","* It *is* necessary to call this method when you stop","* using a tree. Failure to do so will cause a memory leak.","*","* @param tree the tree to close","*/"],"line":55,"args":"git_tree *tree","return":"GIT_INLINE(void)"},"git_revwalk_new":{"comments":["/**","* Allocate a new revision walker to iterate through a repo.","*","* This revision walker uses a custom memory pool and an internal","* commit cache, so it is relatively expensive to allocate.","*","* For maximum performance, this revision walker should be","* reused for different walks.","*","* This revision walker is *not* thread safe: it may only be","* used to walk a repository on a single thread; however,","* it is possible to have several revision walkers in","* several different threads walking the same repository.","*","* @param walker pointer to the new revision walker","* @param repo the repo to walk through","* @return 0 on success; error code otherwise","*/"],"line":70,"args":"git_revwalk **walker, git_repository *repo","return":"GIT_EXTERN(int)"},"git_signature_new":{"comments":["/**","* Create a new action signature. The signature must be freed","* manually or using git_signature_free","*","* @param name name of the person","* @param mail email of the person","* @param time time when the action happened","* @param offset timezone offset in minutes for the time","* @return the new sig, NULL on out of memory","*/"],"line":40,"args":"const char *name, const char *email, git_time_t time, int offset","return":"GIT_EXTERN(git_signature *)"},"git_oid_cmp":{"comments":["/**","* Compare two oid structures.","* @param a first oid structure.","* @param b second oid structure.","* @return <0, 0, >0 if a < b, a == b, a > b.","*/"],"line":127,"args":"const git_oid *a, const git_oid *b","return":"GIT_EXTERN(int)"},"git_signature_dup":{"comments":["/**","* Create a copy of an existing signature.","*","* All internal strings are also duplicated.","* @param sig signature to duplicated","* @return a copy of sig, NULL on out of memory","*/"],"line":63,"args":"const git_signature *sig","return":"GIT_EXTERN(git_signature *)"},"git_repository_index":{"comments":["/**","* Get the Index file of a Git repository","*","* This is a cheap operation; the index is only opened on the first call,","* and subsequent calls only retrieve the previous pointer.","*","* @param index Pointer where to store the index","* @param repo a repository object","* @return 0 on success; error code if the index could not be opened","*/"],"line":143,"args":"git_index **index, git_repository *repo","return":"GIT_EXTERN(int)"},"git_tag_name":{"comments":["/**","* Get the name of a tag","*","* @param tag a previously loaded tag.","* @return name of the tag","*/"],"line":109,"args":"git_tag *t","return":"GIT_EXTERN(const char *)"},"git_blob_rawcontent":{"comments":["/**","* Get a read-only buffer with the raw content of a blob.","*","* A pointer to the raw content of a blob is returned;","* this pointer is owned internally by the object and shall","* not be free'd. The pointer may be invalidated at a later","* time.","*","* @param blob pointer to the blob","* @return the pointer; NULL if the blob has no contents","*/"],"line":73,"args":"git_blob *blob","return":"GIT_EXTERN(const void *)"},"git_object_typeisloose":{"comments":["/**","* Determine if the given git_otype is a valid loose object type.","*","* @param type object type to test.","* @return true if the type represents a valid loose object type,","* false otherwise.","*/"],"line":121,"args":"git_otype type","return":"GIT_EXTERN(int)"},"git_revwalk_repository":{"comments":["/**","* Return the repository on which this walker","* is operating.","*","* @param walk the revision walker","* @return the repository being walked","*/"],"line":176,"args":"git_revwalk *walk","return":"GIT_EXTERN(git_repository *)"},"git_reference_type":{"comments":["/**","* Get the type of a reference","*","* Either direct (GIT_REF_OID) or symbolic (GIT_REF_SYMBOLIC)","*","* @param ref The reference","* @return the type","*/"],"line":150,"args":"git_reference *ref","return":"GIT_EXTERN(git_rtype)"},"git_odb_add_alternate":{"comments":["/**","* Add a custom backend to an existing Object DB; this","* backend will work as an alternate.","*","* Alternate backends are always checked for objects *after*","* all the main backends have been exhausted.","*","* Writing is disabled on alternate backends.","*","* Read <odb_backends.h> for more information.","*","* @param odb database to add the backend to","* @paramm backend pointer to a git_odb_backend instance","* @return 0 on sucess; error code otherwise","*/"],"line":85,"args":"git_odb *odb, git_odb_backend *backend, int priority","return":"GIT_EXTERN(int)"},"git_revwalk_hide":{"comments":["/**","* Mark a commit (and its ancestors) uninteresting for the output.","*","* The given OID must belong to a commit on the walked","* repository.","*","* The resolved commit and all its parents will be hidden from the","* output on the revision walk.","*","* @param walker the walker being used for the traversal.","* @param commit the commit that will be ignored during the traversal","* @return 0 on success; error code otherwise","*/"],"line":123,"args":"git_revwalk *walk, const git_oid *oid","return":"GIT_EXTERN(int)"},"git_index_append":{"comments":["/**","* Add (append) an index entry from a file in disk","*","* A new entry will always be inserted into the index;","* if the index already contains an entry for such","* path, the old entry will **not** be replaced.","*","* The file `path` must be relative to the repository's","* working folder and must be readable.","*","* This method will fail in bare index instances.","*","* @param index an existing index object","* @param path filename to add","* @param stage stage for the entry","* @return 0 on success, otherwise an error code","*/"],"line":201,"args":"git_index *index, const char *path, int stage","return":"GIT_EXTERN(int)"},"git_reference_create_symbolic":{"comments":["/**","* Create a new symbolic reference.","*","* The reference will be created in the repository and written","* to the disk.","*","* This reference is owned by the repository and shall not","* be free'd by the user.","*","* @param ref_out Pointer to the newly created reference","* @param repo Repository where that reference will live","* @param name The name of the reference","* @param target The target of the reference","* @return 0 on success; error code otherwise","*/"],"line":54,"args":"git_reference **ref_out, git_repository *repo, const char *name, const char *target","return":"GIT_EXTERN(int)"},"git_object_id":{"comments":["/**","* Get the id (SHA1) of a repository object","*","* @param obj the repository object","* @return the SHA1 id","*/"],"line":61,"args":"const git_object *obj","return":"GIT_EXTERN(const git_oid *)"},"git_odb_hash":{"comments":["/**","* Determine the object-ID (sha1 hash) of a data buffer","*","* The resulting SHA-1 OID will the itentifier for the data","* buffer as if the data buffer it were to written to the ODB.","*","* @param id the resulting object-ID.","* @param data data to hash","* @param len size of the data","* @param type of the data to hash","* @return 0 on success; error code otherwise","*/"],"line":234,"args":"git_oid *id, const void *data, size_t len, git_otype type","return":"GIT_EXTERN(int)"},"git_object_lookup":{"comments":["/**","* Lookup a reference to one of the objects in a repostory.","*","* The generated reference is owned by the repository and","* should be closed with the `git_object_close` method","* instead of free'd manually.","*","* The 'type' parameter must match the type of the object","* in the odb; the method will fail otherwise.","* The special value 'GIT_OBJ_ANY' may be passed to let","* the method guess the object's type.","*","* @param object pointer to the looked-up object","* @param repo the repository to look up the object","* @param id the unique identifier for the object","* @param type the type of the object","* @return a reference to the object","*/"],"line":41,"args":"git_object **object, git_repository *repo, const git_oid *id, git_otype type","return":"GIT_EXTERN(int)"},"git_reference_oid":{"comments":["/**","* Get the OID pointed to by a reference.","*","* Only available if the reference is direct (i.e. not symbolic)","*","* @param ref The reference","* @return a pointer to the oid if available, NULL otherwise","*/"],"line":130,"args":"git_reference *ref","return":"GIT_EXTERN(const git_oid *)"},"git_oid_shorten_free":{"comments":["/**","* Free an OID shortener instance","*","* @param os a `git_oid_shorten` instance","*/"],"line":182,"args":"git_oid_shorten *os","return":"void"},"git_odb_object_data":{"comments":["/**","* Return the data of an ODB object","*","* This is the uncompressed, raw data as read from the ODB,","* without the leading header.","*","* This pointer is owned by the object and shall not be free'd.","*","* @param object the object","* @return a pointer to the data","*/"],"line":268,"args":"git_odb_object *object","return":"GIT_EXTERN(const void *)"},"git_treebuilder_filter":{"comments":["/**","* Filter the entries in the tree","*","* The `filter` callback will be called for each entry","* in the tree with a pointer to the entry and the","* provided `payload`: if the callback returns 1, the","* entry will be filtered (removed from the builder).","*","* @param bld Tree builder","* @param filter Callback to filter entries","*/"],"line":237,"args":"git_treebuilder *bld, int (*filter)(const git_tree_entry *, void *), void *payload","return":"GIT_EXTERN(void)"},"git_repository_database":{"comments":["/**","* Get the object database behind a Git repository","*","* @param repo a repository object","* @return a pointer to the object db","*/"],"line":135,"args":"git_repository *repo","return":"GIT_EXTERN(git_odb *)"},"git_tree_entry_id":{"comments":["/**","* Get the id of the object pointed by the entry","*","* @param entry a tree entry","* @return the oid of the object","*/"],"line":123,"args":"const git_tree_entry *entry","return":"GIT_EXTERN(const git_oid *)"},"git_blob_create_fromfile":{"comments":["/**","* Read a file from the working folder of a repository","* and write it to the Object Database as a loose blob","*","* @param oid return the id of the written blob","* @param repo repository where the blob will be written.","*\tthis repository cannot be bare","* @param path file from which the blob will be created,","*\trelative to the repository's working dir","* @return 0 on success; error code otherwise","*/"],"line":94,"args":"git_oid *oid, git_repository *repo, const char *path","return":"GIT_EXTERN(int)"},"git_tree_entry_byname":{"comments":["/**","* Lookup a tree entry by its filename","*","* @param tree a previously loaded tree.","* @param filename the filename of the desired entry","* @return the tree entry; NULL if not found","*/"],"line":89,"args":"git_tree *tree, const char *filename","return":"GIT_EXTERN(const git_tree_entry *)"},"git_odb_close":{"comments":["/**","* Close an open object database.","*","* @param db database pointer to close.  If NULL no action is taken.","*/"],"line":102,"args":"git_odb *db","return":"GIT_EXTERN(void)"},"git_reference_create_oid_f":{"comments":["/**","* Create a new object id reference, overwriting an existing one with","* the same name, if it exists.","*","* If the new reference isn't an object id one, any pointers to the","* old reference become invalid.","*","* The reference will be created in the repository and written","* to the disk.","*","* This reference is owned by the repository and shall not","* be free'd by the user.","*","* @param ref_out Pointer to the newly created reference","* @param repo Repository where that reference will live","* @param name The name of the reference","* @param id The object id pointed to by the reference.","* @return 0 on success; error code otherwise","*/"],"line":109,"args":"git_reference **ref_out, git_repository *repo, const char *name, const git_oid *id","return":"GIT_EXTERN(int)"},"git_tag_id":{"comments":["/**","* Get the id of a tag.","*","* @param tag a previously loaded tag.","* @return object identity for the tag.","*/"],"line":73,"args":"git_tag *tag","return":"GIT_EXTERN(const git_oid *)"},"git_reference_target":{"comments":["/**","* Get full name to the reference pointed by this reference","*","* Only available if the reference is symbolic","*","* @param ref The reference","* @return a pointer to the name if available, NULL otherwise","*/"],"line":140,"args":"git_reference *ref","return":"GIT_EXTERN(const char *)"},"git_odb_add_backend":{"comments":["/**","* Add a custom backend to an existing Object DB","*","* Read <odb_backends.h> for more information.","*","* @param odb database to add the backend to","* @paramm backend pointer to a git_odb_backend instance","* @return 0 on sucess; error code otherwise","*/"],"line":74,"args":"git_odb *odb, git_odb_backend *backend, int priority","return":"GIT_EXTERN(int)"},"git_object_type":{"comments":["/**","* Get the object type of an object","*","* @param obj the repository object","* @return the object's type","*/"],"line":69,"args":"const git_object *obj","return":"GIT_EXTERN(git_otype)"},"git_index_add":{"comments":["/**","* Add or update an index entry from a file in disk","*","* The file `path` must be relative to the repository's","* working folder and must be readable.","*","* This method will fail in bare index instances.","*","* @param index an existing index object","* @param path filename to add","* @param stage stage for the entry","* @return 0 on success, otherwise an error code","*/"],"line":174,"args":"git_index *index, const char *path, int stage","return":"GIT_EXTERN(int)"},"git_treebuilder_clear":{"comments":["/**","* Clear all the entires in the builder","*","* @param bld Builder to clear","*/"],"line":178,"args":"git_treebuilder *bld","return":"GIT_EXTERN(void)"},"git_index_get":{"comments":["/**","* Get a pointer to one of the entries in the index","*","* This entry can be modified, and the changes will be written","* back to disk on the next write() call.","*","* @param index an existing index object","* @param n the position of the entry","* @return a pointer to the entry; NULL if out of bounds","*/"],"line":247,"args":"git_index *index, int n","return":"GIT_EXTERN(git_index_entry *)"},"git_repository_free":{"comments":["/**","* Free a previously allocated repository","*","* Note that after a repository is free'd, all the objects it has spawned","* will still exist until they are manually closed by the user","* with `git_object_close`, but accessing any of the attributes of","* an object without a backing repository will result in undefined","* behavior","*","* @param repo repository handle to close. If NULL nothing occurs.","*/"],"line":155,"args":"git_repository *repo","return":"GIT_EXTERN(void)"},"git_oid_cpy":{"comments":["/**","* Copy an oid from one structure to another.","* @param out oid structure the result is written into.","* @param src oid structure to copy from.","*/"],"line":120,"args":"git_oid *out, const git_oid *src","return":"GIT_EXTERN(void)"},"git_index_open_inrepo":{"comments":["/**","* Open the Index inside the git repository pointed","* by 'repo'.","*","* @param index the pointer for the new index","* @param repo the git repo which owns the index","* @return 0 on success; error code otherwise","*/"],"line":120,"args":"git_index **index, git_repository *repo","return":"GIT_EXTERN(int)"},"git_treebuilder_get":{"comments":["/**","* Get an entry from the builder from its filename","*","* The returned entry is owned by the builder and should","* not be freed manually.","*","* @param bld Tree builder","* @param filename Name of the entry","* @return pointer to the entry; NULL if not found","*/"],"line":196,"args":"git_treebuilder *bld, const char *filename","return":"GIT_EXTERN(const git_tree_entry *)"},"git_oid_shorten_add":{"comments":["/**","* Add a new OID to set of shortened OIDs and calculate","* the minimal length to uniquely identify all the OIDs in","* the set.","*","* The OID is expected to be a 40-char hexadecimal string.","* The OID is owned by the user and will not be modified","* or freed.","*","* For performance reasons, there is a hard-limit of how many","* OIDs can be added to a single set (around ~22000, assuming","* a mostly randomized distribution), which should be enough","* for any kind of program, and keeps the algorithm fast and","* memory-efficient.","*","* Attempting to add more than those OIDs will result in a","* GIT_ENOMEM error","*","* @param os a `git_oid_shorten` instance","* @param text_oid an OID in text form","* @return the minimal length to uniquely identify all OIDs","*\t\tadded so far to the set; or an error code (<0) if an","*\t\terror occurs.","*/"],"line":156,"args":"git_oid_shorten *os, const char *text_oid","return":"int"},"git_blob_close":{"comments":["/**","* Close an open blob","*","* This is a wrapper around git_object_close()","*","* IMPORTANT:","* It *is* necessary to call this method when you stop","* using a blob. Failure to do so will cause a memory leak.","*","* @param blob the blob to close","*/"],"line":55,"args":"git_blob *blob","return":"GIT_INLINE(void)"},"git_revwalk_next":{"comments":["/**","* Get the next commit from the revision walk.","*","* The initial call to this method is *not* blocking when","* iterating through a repo with a time-sorting mode.","*","* Iterating with Topological or inverted modes makes the initial","* call blocking to preprocess the commit list, but this block should be","* mostly unnoticeable on most repositories (topological preprocessing","* times at 0.3s on the git.git repo).","*","* The revision walker is reset when the walk is over.","*","* @param oid Pointer where to store the oid of the next commit","* @param walk the walker to pop the commit from.","* @return GIT_SUCCESS if the next commit was found;","*\tGIT_EREVWALKOVER if there are no commits left to iterate","*/"],"line":138,"args":"git_oid *oid, git_revwalk *walk","return":"GIT_EXTERN(int)"},"git_repository_init":{"comments":["/**","* Creates a new Git repository in the given folder.","*","* TODO:","*\t- Reinit the repository","*\t- Create config files","*","* @param repo_out pointer to the repo which will be created or reinitialized","* @param path the path to the repository","* @param is_bare if true, a Git repository without a working directory is created","*\t\tat the pointed path. If false, provided path will be considered as the working","*\t\tdirectory into which the .git directory will be created.","*","* @return 0 on success; error code otherwise","*/"],"line":168,"args":"git_repository **repo_out, const char *path, unsigned is_bare","return":"GIT_EXTERN(int)"},"git_index_clear":{"comments":["/**","* Clear the contents (all the entries) of an index object.","* This clears the index object in memory; changes must be manually","* written to disk for them to take effect.","*","* @param index an existing index object","*/"],"line":130,"args":"git_index *index","return":"GIT_EXTERN(void)"},"git_repository_workdir":{"comments":["/**","* Get the normalized path to the working directory of the repository.","*","* If the repository is bare, there is no working directory and NULL we be returned.","*","* @param repo a repository object","* @return NULL if the repository is bare; absolute path to the working directory otherwise.","*/"],"line":205,"args":"git_repository *repo","return":"GIT_EXTERN(const char *)"},"git_treebuilder_remove":{"comments":["/**","* Remove an entry from the builder by its filename","*","* @param bld Tree builder","* @param filename Filename of the entry to remove","*/"],"line":229,"args":"git_treebuilder *bld, const char *filename","return":"GIT_EXTERN(int)"},"git_tree_entrycount":{"comments":["/**","* Get the number of entries listed in a tree","*","* @param tree a previously loaded tree.","* @return the number of entries in the tree","*/"],"line":81,"args":"git_tree *tree","return":"GIT_EXTERN(size_t)"},"git_commit_time":{"comments":["/**","* Get the commit time (i.e. committer time) of a commit.","*","* @param commit a previously loaded commit.","* @return the time of a commit","*/"],"line":97,"args":"git_commit *commit","return":"GIT_EXTERN(git_time_t)"},"git_index_free":{"comments":["/**","* Free an existing index object.","*","* @param index an existing index object","*/"],"line":139,"args":"git_index *index","return":"GIT_EXTERN(void)"},"git_index_write":{"comments":["/**","* Write an existing index object from memory back to disk","* using an atomic file lock.","*","* @param index an existing index object","* @return 0 on success, otherwise an error code","*/"],"line":155,"args":"git_index *index","return":"GIT_EXTERN(int)"},"git_tag_target":{"comments":["/**","* Get the tagged object of a tag","*","* This method performs a repository lookup for the","* given object and returns it","*","* @param target pointer where to store the target","* @param tag a previously loaded tag.","* @return 0 on success; error code otherwise","*/"],"line":81,"args":"git_object **target, git_tag *t","return":"GIT_EXTERN(int)"},"git_odb_object_id":{"comments":["/**","* Return the OID of an ODB object","*","* This is the OID from which the object was read from","*","* @param object the object","* @return a pointer to the OID","*/"],"line":258,"args":"git_odb_object *object","return":"GIT_EXTERN(const git_oid *)"},"git_revwalk_push":{"comments":["/**","* Mark a commit to start traversal from.","*","* The given OID must belong to a commit on the walked","* repository.","*","* The given commit will be used as one of the roots","* when starting the revision walk. At least one commit","* must be pushed the repository before a walk can","* be started.","*","* @param walker the walker being used for the traversal.","* @param oid the oid of the commit to start from.","* @return 0 on success; error code otherwise","*/"],"line":105,"args":"git_revwalk *walk, const git_oid *oid","return":"GIT_EXTERN(int)"},"git_blob_lookup":{"comments":["/**","* Lookup a blob object from a repository.","*","* @param blob pointer to the looked up blob","* @param repo the repo to use when locating the blob.","* @param id identity of the blob to locate.","* @return 0 on success; error code otherwise","*/"],"line":42,"args":"git_blob **blob, git_repository *repo, const git_oid *id","return":"GIT_INLINE(int)"},"git_tag_tagger":{"comments":["/**","* Get the tagger (author) of a tag","*","* @param tag a previously loaded tag.","* @return reference to the tag's author","*/"],"line":117,"args":"git_tag *t","return":"GIT_EXTERN(const git_signature *)"},"git_odb_new":{"comments":["/**","* Create a new object database with no backends.","*","* Before the ODB can be used for read/writing, a custom database","* backend must be manually added using `git_odb_add_backend()`","*","* @param out location to store the database pointer, if opened.","*            Set to NULL if the open failed.","* @return GIT_SUCCESS if the database was created; otherwise an error","*         code describing why the open was not possible.","*/"],"line":42,"args":"git_odb **out","return":"GIT_EXTERN(int)"},"git_commit_tree":{"comments":["/**","* Get the tree pointed to by a commit.","*","* @param tree_out pointer where to store the tree object","* @param commit a previously loaded commit.","* @return 0 on success; error code otherwise","*/"],"line":129,"args":"git_tree **tree_out, git_commit *commit","return":"GIT_EXTERN(int)"},"git_oid_allocfmt":{"comments":["/**","* Format a gid_oid into a newly allocated c-string.","* @param oid the oid structure to format","* @return the c-string; NULL if memory is exhausted.  Caller must","*         deallocate the string with free().","*/"],"line":95,"args":"const git_oid *oid","return":"GIT_EXTERN(char *)"},"git_treebuilder_free":{"comments":["/**","* Free a tree builder","*","* This will clear all the entries and free to builder.","* Failing to free the builder after you're done using it","* will result in a memory leak","*","* @param bld Builder to free","*/"],"line":185,"args":"git_treebuilder *bld","return":"GIT_EXTERN(void)"},"git_tree_create_fromindex":{"comments":["/**","* Write a tree to the ODB from the index file","*","* This method will scan the index and write a representation","* of its current state back to disk; it recursively creates","* tree objects for each of the subtrees stored in the index,","* but only returns the OID of the root tree. This is the OID","* that can be used e.g. to create a commit.","*","* The index instance cannot be bare, and needs to be associated","* to an existing repository.","*","* @param oid Pointer where to store the written tree","* @param index Index to write","* @return 0 on success; error code otherwise","*/"],"line":141,"args":"git_oid *oid, git_index *index","return":"GIT_EXTERN(int)"},"git_reference_lookup":{"comments":["/**","* Lookup a reference by its name in a repository.","*","* The generated reference is owned by the repository and","* should not be freed by the user.","*","* @param reference_out pointer to the looked-up reference","* @param repo the repository to look up the reference","* @param name the long name for the reference (e.g. HEAD, ref/heads/master, refs/tags/v0.1.0, ...)","* @return 0 on success; error code otherwise","*/"],"line":41,"args":"git_reference **reference_out, git_repository *repo, const char *name","return":"GIT_EXTERN(int)"},"git_odb_open_rstream":{"comments":["/**","* Open a stream to read an object from the ODB","*","* Note that most backends do *not* support streaming reads","* because they store their objects as compressed/delta'ed blobs.","*","* It's recommended to use `git_odb_read` instead, which is","* assured to work on all backends.","*","* The returned stream will be of type `GIT_STREAM_RDONLY` and","* will have the following methods:","*","*\t\t- stream->read: read `n` bytes from the stream","*\t\t- stream->free: free the stream","*","* The stream must always be free'd or will leak memory.","*","* @see git_odb_stream","*","* @param stream pointer where to store the stream","* @param db object database where the stream will read from","* @param oid oid of the object the stream will read from","* @return 0 if the stream was created; error code otherwise","*/"],"line":208,"args":"git_odb_stream **stream, git_odb *db, const git_oid *oid","return":"GIT_EXTERN(int)"},"git_commit_committer":{"comments":["/**","* Get the committer of a commit.","*","* @param commit a previously loaded commit.","* @return the committer of a commit","*/"],"line":113,"args":"git_commit *commit","return":"GIT_EXTERN(const git_signature *)"},"git_reference_resolve":{"comments":["/**","* Resolve a symbolic reference","*","* Thie method iteratively peels a symbolic reference","* until it resolves to a direct reference to an OID.","*","* If a direct reference is passed as an argument,","* that reference is returned immediately","*","* @param resolved_ref Pointer to the peeled reference","* @param ref The reference","* @return 0 on success; error code otherwise","*/"],"line":168,"args":"git_reference **resolved_ref, git_reference *ref","return":"GIT_EXTERN(int)"},"git_reference_name":{"comments":["/**","* Get the full name of a reference","*","* @param ref The reference","* @return the full name for the ref","*/"],"line":160,"args":"git_reference *ref","return":"GIT_EXTERN(const char *)"},"git_odb_exists":{"comments":["/**","* Determine if the given object can be found in the object database.","*","* @param db database to be searched for the given object.","* @param id the object to search for.","* @return","* - 1, if the object was found","* - 0, otherwise","*/"],"line":148,"args":"git_odb *db, const git_oid *id","return":"GIT_EXTERN(int)"},"git_reference_create_symbolic_f":{"comments":["/**","* Create a new symbolic reference, overwriting an existing one with","* the same name, if it exists.","*","* If the new reference isn't a symbolic one, any pointers to the old","* reference become invalid.","*","* The reference will be created in the repository and written","* to the disk.","*","* This reference is owned by the repository and shall not","* be free'd by the user.","*","* @param ref_out Pointer to the newly created reference","* @param repo Repository where that reference will live","* @param name The name of the reference","* @param target The target of the reference","* @return 0 on success; error code otherwise","*/"],"line":71,"args":"git_reference **ref_out, git_repository *repo, const char *name, const char *target","return":"GIT_EXTERN(int)"},"git_tag_message":{"comments":["/**","* Get the message of a tag","*","* @param tag a previously loaded tag.","* @return message of the tag","*/"],"line":125,"args":"git_tag *t","return":"GIT_EXTERN(const char *)"},"git_signature_now":{"comments":["/**","* Create a new action signature with a timestamp of 'now'. The","* signature must be freed manually or using git_signature_free","*","* @param name name of the person","* @param email email of the person","* @return the new sig, NULL on out of memory","*/"],"line":52,"args":"const char *name, const char *email","return":"GIT_EXTERN(git_signature *)"},"git_reference_owner":{"comments":["/**","* Get the repository where a reference resides","*","* @param ref The reference","* @return a pointer to the repo","*/"],"line":183,"args":"git_reference *ref","return":"GIT_EXTERN(git_repository *)"},"git_reference_packall":{"comments":["/**","* Pack all the loose references in the repository","*","* This method will load into the cache all the loose","* references on the repository and update the","* `packed-refs` file with them.","*","* Once the `packed-refs` file has been written properly,","* the loose references will be removed from disk.","*","* WARNING: calling this method may invalidate any existing","* references previously loaded on the cache.","*","* @param repo Repository where the loose refs will be packed","* @return 0 on success; error code otherwise","*/"],"line":259,"args":"git_repository *repo","return":"GIT_EXTERN(int)"},"git_strerror":{"comments":["/**","* strerror() for the Git library","*","* Get a string description for a given error code.","* NOTE: This method will be eventually deprecated in favor","* of the new `git_lasterror`.","*","* @param num The error code to explain","* @return a string explaining the error code","*/"],"line":135,"args":"int num","return":"GIT_EXTERN(const char *)"},"git_oid_pathfmt":{"comments":["/**","* Format a git_oid into a loose-object path string.","* <p>","* The resulting string is \"aa/...\", where \"aa\" is the first two","* hex digitis of the oid and \"...\" is the remaining 38 digits.","*","* @param str output hex string; must be pointing at the start of","*        the hex sequence and have at least the number of bytes","*        needed for an oid encoded in hex (41 bytes).  Only the","*        oid digits are written; a '\\\\0' terminator must be added","*        by the caller if it is required.","* @param oid oid structure to format.","*/"],"line":80,"args":"char *str, const git_oid *oid","return":"GIT_EXTERN(void)"},"git_index_remove":{"comments":["/**","* Remove an entry from the index","*","* @param index an existing index object","* @param position position of the entry to remove","* @return 0 on success, otherwise an error code","*/"],"line":237,"args":"git_index *index, int position","return":"GIT_EXTERN(int)"},"git_blob_rawsize":{"comments":["/**","* Get the size in bytes of the contents of a blob","*","* @param blob pointer to the blob","* @return size on bytes","*/"],"line":86,"args":"git_blob *blob","return":"GIT_EXTERN(int)"},"git_revwalk_sorting":{"comments":["/**","* Change the sorting mode when iterating through the","* repository's contents.","*","* Changing the sorting mode resets the walker.","*","* @param walk the walker being used for the traversal.","* @param sort_mode combination of GIT_SORT_XXX flags","*/"],"line":158,"args":"git_revwalk *walk, unsigned int sort_mode","return":"GIT_EXTERN(void)"},"git_commit_close":{"comments":["/**","* Close an open commit","*","* This is a wrapper around git_object_close()","*","* IMPORTANT:","* It *is* necessary to call this method when you stop","* using a commit. Failure to do so will cause a memory leak.","*","* @param commit the commit to close","*/"],"line":56,"args":"git_commit *commit","return":"GIT_INLINE(void)"},"git_reference_rename_f":{"comments":["/**","* Rename an existing reference, overwriting an existing one with the","* same name, if it exists.","*","* This method works for both direct and symbolic references.","* The new name will be checked for validity and may be","* modified into a normalized form.","*","* The refernece will be immediately renamed in-memory","* and on disk.","*","*/"],"line":234,"args":"git_reference *ref, const char *new_name","return":"GIT_EXTERN(int)"},"git_tree_entry_byindex":{"comments":["/**","* Lookup a tree entry by its position in the tree","*","* @param tree a previously loaded tree.","* @param idx the position in the entry list","* @return the tree entry; NULL if not found","*/"],"line":98,"args":"git_tree *tree, int idx","return":"GIT_EXTERN(const git_tree_entry *)"},"git_tree_id":{"comments":["/**","* Get the id of a tree.","*","* @param tree a previously loaded tree.","* @return object identity for the tree.","*/"],"line":73,"args":"git_tree *tree","return":"GIT_EXTERN(const git_oid *)"},"git_commit_parent":{"comments":["/**","* Get the specified parent of the commit.","*","* @param parent Pointer where to store the parent commit","* @param commit a previously loaded commit.","* @param n the position of the parent (from 0 to `parentcount`)","* @return 0 on success; error code otherwise","*/"],"line":156,"args":"git_commit **parent, git_commit *commit, unsigned int n","return":"GIT_EXTERN(int)"},"git_tag_lookup":{"comments":["/**","* Lookup a tag object from the repository.","*","* @param tag pointer to the looked up tag","* @param repo the repo to use when locating the tag.","* @param id identity of the tag to locate.","* @return 0 on success; error code otherwise","*/"],"line":42,"args":"git_tag **tag, git_repository *repo, const git_oid *id","return":"GIT_INLINE(int)"},"git_commit_id":{"comments":["/**","* Get the id of a commit.","*","* @param commit a previously loaded commit.","* @return object identity for the commit.","*/"],"line":73,"args":"git_commit *commit","return":"GIT_EXTERN(const git_oid *)"},"git_index_find":{"comments":["/**","* Find the first index of any entries which point to given","* path in the Git index.","*","* @param index an existing index object","* @param path path to search","* @return an index >= 0 if found, -1 otherwise","*/"],"line":164,"args":"git_index *index, const char *path","return":"GIT_EXTERN(int)"},"git_lasterror":{"comments":["/**","* Return a detailed error string with the latest error","* that occurred in the library.","* @return a string explaining the error","*/"],"line":128,"args":"void","return":"GIT_EXTERN(const char *)"},"git_commit_parent_oid":{"comments":["/**","* Get the oid of a specified parent for a commit. This is different from","* `git_commit_parent`, which will attempt to load the parent commit from","* the ODB.","*","* @param commit a previously loaded commit.","* @param n the position of the parent (from 0 to `parentcount`)","* @return the id of the parent, NULL on error.","*/"],"line":166,"args":"git_commit *commit, unsigned int n","return":"GIT_EXTERN(const git_oid *)"},"git_odb_read_header":{"comments":["/**","* Read the header of an object from the database, without","* reading its full contents.","*","* The header includes the length and the type of an object.","*","* Note that most backends do not support reading only the header","* of an object, so the whole object will be read and then the","* header will be returned.","*","* @param len_p pointer where to store the length","* @param type_p pointer where to store the type","* @param db database to search for the object in.","* @param id identity of the object to read.","* @return","* - GIT_SUCCESS if the object was read;","* - GIT_ENOTFOUND if the object is not in the database.","*/"],"line":128,"args":"size_t *len_p, git_otype *type_p, git_odb *db, const git_oid *id","return":"GIT_EXTERN(int)"},"git_tag_target_oid":{"comments":["/**","* Get the OID of the tagged object of a tag","*","* @param tag a previously loaded tag.","* @return pointer to the OID","*/"],"line":93,"args":"git_tag *t","return":"GIT_EXTERN(const git_oid *)"},"git_repository_open":{"comments":["/**","* Open a git repository.","*","* The 'path' argument must point to an existing git repository","* folder, e.g.","*","*\t\t/path/to/my_repo/.git/\t(normal repository)","*\t\t\t\t\t\t\tobjects/","*\t\t\t\t\t\t\tindex","*\t\t\t\t\t\t\tHEAD","*","*\t\t/path/to/bare_repo/\t\t(bare repository)","*\t\t\t\t\t\tobjects/","*\t\t\t\t\t\tindex","*\t\t\t\t\t\tHEAD","*","*\tThe method will automatically detect if 'path' is a normal","*\tor bare repository or fail is 'path' is neither.","*","* @param repository pointer to the repo which will be opened","* @param path the path to the repository","* @return 0 on success; error code otherwise","*/"],"line":41,"args":"git_repository **repository, const char *path","return":"GIT_EXTERN(int)"},"git_index_read":{"comments":["/**","* Update the contents of an existing index object in memory","* by reading from the hard disk.","*","* @param index an existing index object","* @return 0 on success, otherwise an error code","*/"],"line":146,"args":"git_index *index","return":"GIT_EXTERN(int)"},"git_signature_free":{"comments":["/**","* Free an existing signature","*","* @param sig signature to free","*/"],"line":72,"args":"git_signature *sig","return":"GIT_EXTERN(void)"},"git_commit_author":{"comments":["/**","* Get the author of a commit.","*","* @param commit a previously loaded commit.","* @return the author of a commit","*/"],"line":121,"args":"git_commit *commit","return":"GIT_EXTERN(const git_signature *)"},"git_odb_write":{"comments":["/**","* Write an object directly into the ODB","*","* This method writes a full object straight into the ODB.","* For most cases, it is preferred to write objects through a write","* stream, which is both faster and less memory intensive, specially","* for big objects.","*","* This method is provided for compatibility with custom backends","* which are not able to support streaming writes","*","* @param oid pointer to store the OID result of the write","* @param odb object database where to store the object","* @param data buffer with the data to storr","* @param len size of the buffer","* @param type type of the data to store","* @return 0 on success; error code otherwise","*/"],"line":159,"args":"git_oid *oid, git_odb *odb, const void *data, size_t len, git_otype type","return":"GIT_EXTERN(int)"},"git_reference_listall":{"comments":["/**","* Fill a list with all the references that can be found","* in a repository.","*","* The listed references may be filtered by type, or using","* a bitwise OR of several types. Use the magic value","* `GIT_REF_LISTALL` to obtain all references, including","* packed ones.","*","* The string array will be filled with the names of all","* references; these values are owned by the user and","* should be free'd manually when no longer needed, using","* `git_strarray_free`.","*","* @param array Pointer to a git_strarray structure where","*\t\tthe reference names will be stored","* @param repo Repository where to find the refs","* @param list_flags Filtering flags for the reference","*\t\tlisting.","* @return 0 on success; error code otherwise","*/"],"line":277,"args":"git_strarray *array, git_repository *repo, unsigned int list_flags","return":"GIT_EXTERN(int)"},"git_odb_open_wstream":{"comments":["/**","* Open a stream to write an object into the ODB","*","* The type and final length of the object must be specified","* when opening the stream.","*","* The returned stream will be of type `GIT_STREAM_WRONLY` and","* will have the following methods:","*","*\t\t- stream->write: write `n` bytes into the stream","*\t\t- stream->finalize_write: close the stream and store the object in","*\t\t\tthe odb","*\t\t- stream->free: free the stream","*","* The streaming write won't be effective until `stream->finalize_write`","* is called and returns without an error","*","* The stream must always be free'd or will leak memory.","*","* @see git_odb_stream","*","* @param stream pointer where to store the stream","* @param db object database where the stream will write","* @param size final size of the object that will be written","* @param type type of the object that will be written","* @return 0 if the stream was created; error code otherwise","*/"],"line":179,"args":"git_odb_stream **stream, git_odb *db, size_t size, git_otype type","return":"GIT_EXTERN(int)"},"git_repository_path":{"comments":["/**","* Get the normalized path to the git repository.","*","* @param repo a repository object","* @return absolute path to the git directory","*/"],"line":197,"args":"git_repository *repo","return":"GIT_EXTERN(const char *)"},"git_odb_read":{"comments":["/**","* Read an object from the database.","*","* This method queries all avaiable ODB backends","* trying to read the given OID.","*","* The returned object is reference counted and","* internally cached, so it should be closed","* by the user once it's no longer in use.","*","* @param out pointer where to store the read object","* @param db database to search for the object in.","* @param id identity of the object to read.","* @return","* - GIT_SUCCESS if the object was read;","* - GIT_ENOTFOUND if the object is not in the database.","*/"],"line":109,"args":"git_odb_object **out, git_odb *db, const git_oid *id","return":"GIT_EXTERN(int)"},"git_tag_type":{"comments":["/**","* Get the type of a tag's tagged object","*","* @param tag a previously loaded tag.","* @return type of the tagged object","*/"],"line":101,"args":"git_tag *t","return":"GIT_EXTERN(git_otype)"},"git_reference_set_oid":{"comments":["/**","* Set the OID target of a reference.","*","* The reference must be a direct reference, otherwise","* this method will fail.","*","* The reference will be automatically updated in","* memory and on disk.","*","* @param ref The reference","* @param target The new target OID for the reference","* @return 0 on success; error code otherwise","*/"],"line":206,"args":"git_reference *ref, const git_oid *id","return":"GIT_EXTERN(int)"},"git_index_open_bare":{"comments":["/**","* Create a new Git index object as a memory representation","* of the Git index file in 'index_path', without a repository","* to back it.","*","* Since there is no ODB behind this index, any Index methods","* which rely on the ODB (e.g. index_add) will fail with the","* GIT_EBAREINDEX error code.","*","* @param index the pointer for the new index","* @param index_path the path to the index file in disk","* @return 0 on success; error code otherwise","*/"],"line":105,"args":"git_index **index, const char *index_path","return":"GIT_EXTERN(int)"},"git_tree_entry_name":{"comments":["/**","* Get the filename of a tree entry","*","* @param entry a tree entry","* @return the name of the file","*/"],"line":115,"args":"const git_tree_entry *entry","return":"GIT_EXTERN(const char *)"},"git_object__size":{"comments":["/**","* Get the size in bytes for the structure which","* acts as an in-memory representation of any given","* object type.","*","* For all the core types, this would the equivalent","* of calling `sizeof(git_commit)` if the core types","* were not opaque on the external API.","*","* @param type object type to get its size","* @return size in bytes of the object","*/"],"line":130,"args":"git_otype type","return":"GIT_EXTERN(size_t)"},"git_commit_lookup":{"comments":["/**","* Lookup a commit object from a repository.","*","* @param commit pointer to the looked up commit","* @param repo the repo to use when locating the commit.","* @param id identity of the commit to locate.  If the object is","*        an annotated tag it will be peeled back to the commit.","* @return 0 on success; error code otherwise","*/"],"line":42,"args":"git_commit **commit, git_repository *repo, const git_oid *id","return":"GIT_INLINE(int)"},"git_reference_listcb":{"comments":["/**","* List all the references in the repository, calling a custom","* callback for each one.","*","* The listed references may be filtered by type, or using","* a bitwise OR of several types. Use the magic value","* `GIT_REF_LISTALL` to obtain all references, including","* packed ones.","*","* The `callback` function will be called for each of the references","* in the repository, and will receive the name of the reference and","* the `payload` value passed to this method.","*","* @param repo Repository where to find the refs","* @param list_flags Filtering flags for the reference","*\t\tlisting.","* @param callback Function which will be called for every listed ref","* @param payload Additional data to pass to the callback","* @return 0 on success; error code otherwise","*/"],"line":301,"args":"git_repository *repo, unsigned int list_flags, int (*callback)(const char *, void *), void *payload","return":"GIT_EXTERN(int)"},"git_object_owner":{"comments":["/**","* Get the repository that owns this object","*","* @param obj the object","* @return the repository who owns this object","*/"],"line":77,"args":"const git_object *obj","return":"GIT_EXTERN(git_repository *)"},"git_oid_fmt":{"comments":["/**","* Format a git_oid into a hex string.","* @param str output hex string; must be pointing at the start of","*        the hex sequence and have at least the number of bytes","*        needed for an oid encoded in hex (40 bytes).  Only the","*        oid digits are written; a '\\\\0' terminator must be added","*        by the caller if it is required.","* @param oid oid structure to format.","*/"],"line":69,"args":"char *str, const git_oid *oid","return":"GIT_EXTERN(void)"},"git_commit_message_short":{"comments":["/**","* Get the short (one line) message of a commit.","*","* @param commit a previously loaded commit.","* @return the short message of a commit","*/"],"line":81,"args":"git_commit *commit","return":"GIT_EXTERN(const char *)"},"git_commit_tree_oid":{"comments":["/**","* Get the id of the tree pointed to by a commit. This differs from","* `git_commit_tree` in that no attempts are made to fetch an object","* from the ODB.","*","* @param commit a previously loaded commit.","* @return the id of tree pointed to by commit.","*/"],"line":138,"args":"git_commit *commit","return":"GIT_EXTERN(const git_oid *)"},"git_repository_is_empty":{"comments":["/**","* Check if a repository is empty","*","* An empty repository has just been initialized and contains","* no commits.","*","* @param repo Repo to test","* @return 1 if the repository is empty, 0 if it isn't, error code","* if the repository is corrupted","*/"],"line":185,"args":"git_repository *repo","return":"GIT_EXTERN(int)"},"git_reference_delete":{"comments":["/**","* Delete an existing reference","*","* This method works for both direct and symbolic references.","*","* The reference will be immediately removed on disk and from","* memory. The given reference pointer will no longer be valid.","*","*/"],"line":248,"args":"git_reference *ref","return":"GIT_EXTERN(int)"},"git_odb_object_type":{"comments":["/**","* Return the type of an ODB object","*","* @param object the object","* @return the type","*/"],"line":292,"args":"git_odb_object *object","return":"GIT_EXTERN(git_otype)"},"git_odb_object_size":{"comments":["/**","* Return the size of an ODB object","*","* This is the real size of the `data` buffer, not the","* actual size of the object.","*","* @param object the object","* @return the size","*/"],"line":281,"args":"git_odb_object *object","return":"GIT_EXTERN(size_t)"},"git_odb_object_close":{"comments":["/**","* Close an ODB object","*","* This method must always be called once a `git_odb_object` is no","* longer needed, otherwise memory will leak.","*","* @param object object to close","*/"],"line":248,"args":"git_odb_object *object","return":"GIT_EXTERN(void)"},"git_blob_create_frombuffer":{"comments":["/**","* Write an in-memory buffer to the ODB as a blob","*","* @param oid return the oid of the written blob","* @param repo repository where to blob will be written","* @param buffer data to be written into the blob","* @param len length of the data","* @return 0 on success; error code otherwise","*/"],"line":108,"args":"git_oid *oid, git_repository *repo, const void *buffer, size_t len","return":"GIT_EXTERN(int)"},"git_oid_to_string":{"comments":["/**","* Format a git_oid into a buffer as a hex format c-string.","* <p>","* If the buffer is smaller than GIT_OID_HEXSZ+1, then the resulting","* oid c-string will be truncated to n-1 characters. If there are","* any input parameter errors (out == NULL, n == 0, oid == NULL),","* then a pointer to an empty string is returned, so that the return","* value can always be printed.","*","* @param out the buffer into which the oid string is output.","* @param n the size of the out buffer.","* @param oid the oid structure to format.","* @return the out buffer pointer, assuming no input parameter","*         errors, otherwise a pointer to an empty string.","*/"],"line":103,"args":"char *out, size_t n, const git_oid *oid","return":"GIT_EXTERN(char *)"},"git_index_entrycount":{"comments":["/**","* Get the count of entries currently in the index","*","* @param index an existing index object","* @return integer of count of current entries","*/"],"line":259,"args":"git_index *index","return":"GIT_EXTERN(unsigned int)"},"git_oid_mkraw":{"comments":["/**","* Copy an already raw oid into a git_oid structure.","* @param out oid structure the result is written into.","* @param raw the raw input bytes to be copied.","*/"],"line":62,"args":"git_oid *out, const unsigned char *raw","return":"GIT_EXTERN(void)"},"git_reference_rename":{"comments":["/**","* Rename an existing reference","*","* This method works for both direct and symbolic references.","* The new name will be checked for validity and may be","* modified into a normalized form.","*","* The refernece will be immediately renamed in-memory","* and on disk.","*","*/"],"line":221,"args":"git_reference *ref, const char *new_name","return":"GIT_EXTERN(int)"},"git_revwalk_reset":{"comments":["/**","* Reset the revision walker for reuse.","*","* This will clear all the pushed and hidden commits, and","* leave the walker in a blank state (just like at","* creation) ready to receive new commit pushes and","* start a new walk.","*","* The revision walk is automatically reset when a walk","* is over.","*","* @param walker handle to reset.","*/"],"line":90,"args":"git_revwalk *walker","return":"GIT_EXTERN(void)"},"git_object_close":{"comments":["/**","* Close an open object","*","* This method instructs the library to close an existing","* object; note that git_objects are owned and cached by the repository","* so the object may or may not be freed after this library call,","* depending on how agressive is the caching mechanism used","* by the repository.","*","* IMPORTANT:","* It *is* necessary to call this method when you stop using","* an object. Failure to do so will cause a memory leak.","*","* @param object the object to close","*/"],"line":85,"args":"git_object *object","return":"GIT_EXTERN(void)"}}}