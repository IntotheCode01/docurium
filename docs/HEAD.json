{"files":[{"lines":121,"file":"blob.h","meta":{"file":"git2/blob.h","brief":"Git blob load and write routines","defgroup":"git_blob Git blob load and write routines","ingroup":"Git"},"functions":["git_blob_lookup","git_blob_close","git_blob_rawcontent","git_blob_rawsize","git_blob_create_fromfile","git_blob_create_frombuffer"]},{"lines":302,"file":"commit.h","meta":{"file":"git2/commit.h","brief":"Git commit parsing, formatting routines","defgroup":"git_commit Git commit parsing, formatting routines","ingroup":"Git"},"functions":["git_commit_lookup","git_commit_close","git_commit_id","git_commit_message_short","git_commit_message","git_commit_time","git_commit_time_offset","git_commit_committer","git_commit_author","git_commit_tree","git_commit_tree_oid","git_commit_parentcount","git_commit_parent","git_commit_parent_oid"]},{"lines":98,"file":"common.h","meta":{"file":"git2/common.h","brief":"Git common platform definitions","defgroup":"git_common Git common platform definitions","ingroup":"Git"},"functions":["git_strarray_free"]},{"lines":149,"file":"errors.h","meta":{"file":"git2/errors.h","brief":"Git error handling routines and variables","defgroup":null,"ingroup":"Git"},"functions":["git_lasterror","git_strerror"]},{"lines":270,"file":"index.h","meta":{"file":"git2/index.h","brief":"Git index parsing and manipulation routines","defgroup":"git_index Git index parsing and manipulation routines","ingroup":"Git"},"functions":["git_index_open_bare","git_index_open_inrepo","git_index_clear","git_index_free","git_index_read","git_index_write","git_index_find","git_index_add","git_index_append","git_index_remove","git_index_get","git_index_entrycount"]},{"lines":147,"file":"object.h","meta":{"file":"git2/object.h","brief":"Git revision object management routines","defgroup":"git_object Git revision object management routines","ingroup":"Git"},"functions":["git_object_lookup","git_object_id","git_object_type","git_object_owner","git_object_close","git_object_typeisloose","git_object__size"]},{"lines":302,"file":"odb.h","meta":{"file":"git2/odb.h","brief":"Git object database routines","defgroup":"git_odb Git object database routines","ingroup":"Git"},"functions":["git_odb_new","git_odb_open","git_odb_add_backend","git_odb_add_alternate","git_odb_close","git_odb_read","git_odb_read_header","git_odb_exists","git_odb_write","git_odb_open_wstream","git_odb_open_rstream","git_odb_hash","git_odb_object_close","git_odb_object_id","git_odb_object_data","git_odb_object_size","git_odb_object_type"]},{"lines":107,"file":"odb_backend.h","meta":{"file":"git2/backend.h","brief":"Git custom backend functions","defgroup":"git_backend Git custom backend API","ingroup":"Git"},"functions":["git_odb_backend_pack"]},{"lines":191,"file":"oid.h","meta":{"file":"git2/oid.h","brief":"Git object id routines","defgroup":"git_oid Git object id routines","ingroup":"Git"},"functions":["git_oid_mkstr","git_oid_mkraw","git_oid_fmt","git_oid_pathfmt","git_oid_allocfmt","git_oid_to_string","git_oid_cpy","git_oid_cmp","git_oid_shorten_add","git_oid_shorten_free"]},{"lines":325,"file":"refs.h","meta":{"file":"git2/refs.h","brief":"Git reference management routines","defgroup":"git_reference Git reference management routines","ingroup":"Git"},"functions":["git_reference_lookup","git_reference_create_symbolic","git_reference_create_symbolic_f","git_reference_create_oid","git_reference_create_oid_f","git_reference_oid","git_reference_target","git_reference_type","git_reference_name","git_reference_resolve","git_reference_owner","git_reference_set_target","git_reference_set_oid","git_reference_rename","git_reference_rename_f","git_reference_delete","git_reference_packall","git_reference_listall","git_reference_listcb"]},{"lines":217,"file":"repository.h","meta":{"file":"git2/repository.h","brief":"Git repository management routines","defgroup":"git_repository Git repository management routines","ingroup":"Git"},"functions":["git_repository_open","git_repository_database","git_repository_index","git_repository_free","git_repository_init","git_repository_is_empty","git_repository_path","git_repository_workdir"]},{"lines":187,"file":"revwalk.h","meta":{"file":"git2/revwalk.h","brief":"Git revision traversal routines","defgroup":"git_revwalk Git revision traversal routines","ingroup":"Git"},"functions":["git_revwalk_new","git_revwalk_reset","git_revwalk_push","git_revwalk_hide","git_revwalk_next","git_revwalk_sorting","git_revwalk_free","git_revwalk_repository"]},{"lines":81,"file":"signature.h","meta":{"file":"git2/signature.h","brief":"Git signature creation","defgroup":"git_signature Git signature creation","ingroup":"Git"},"functions":["git_signature_new","git_signature_now","git_signature_dup","git_signature_free"]},{"lines":297,"file":"tag.h","meta":{"file":"git2/tag.h","brief":"Git tag parsing routines","defgroup":"git_tag Git tag management","ingroup":"Git"},"functions":["git_tag_lookup","git_tag_close","git_tag_id","git_tag_target","git_tag_target_oid","git_tag_type","git_tag_name","git_tag_tagger","git_tag_message"]},{"lines":71,"file":"thread-utils.h","meta":{"file":null,"brief":null,"defgroup":null,"ingroup":null},"functions":[]},{"lines":266,"file":"tree.h","meta":{"file":"git2/tree.h","brief":"Git tree parsing, loading routines","defgroup":"git_tree Git tree parsing, loading routines","ingroup":"Git"},"functions":["git_tree_lookup","git_tree_close","git_tree_id","git_tree_entrycount","git_tree_entry_byname","git_tree_entry_byindex","git_tree_entry_attributes","git_tree_entry_name","git_tree_entry_id","git_tree_create_fromindex","git_treebuilder_create","git_treebuilder_clear","git_treebuilder_free","git_treebuilder_get","git_treebuilder_insert","git_treebuilder_remove","git_treebuilder_filter","git_treebuilder_write"]},{"lines":162,"file":"types.h","meta":{"file":"git2/types.h","brief":"libgit2 base & compatibility types","defgroup":null,"ingroup":"Git"},"functions":[]},{"lines":58,"file":"zlib.h","meta":{"file":"git2/zlib.h","brief":"Git data compression routines","defgroup":"git_zlib Git data compression routines","ingroup":"Git"},"functions":[]}],"groups":[["blob",["git_blob_close","git_blob_create_frombuffer","git_blob_create_fromfile","git_blob_lookup","git_blob_rawcontent","git_blob_rawsize"]],["commit",["git_commit_author","git_commit_close","git_commit_committer","git_commit_id","git_commit_lookup","git_commit_message","git_commit_message_short","git_commit_parent","git_commit_parent_oid","git_commit_parentcount","git_commit_time","git_commit_time_offset","git_commit_tree","git_commit_tree_oid"]],["index",["git_index_add","git_index_append","git_index_clear","git_index_entrycount","git_index_find","git_index_free","git_index_get","git_index_open_bare","git_index_open_inrepo","git_index_read","git_index_remove","git_index_write"]],["lasterror",["git_lasterror"]],["object",["git_object__size","git_object_close","git_object_id","git_object_lookup","git_object_owner","git_object_type","git_object_typeisloose"]],["odb",["git_odb_add_alternate","git_odb_add_backend","git_odb_backend_pack","git_odb_close","git_odb_exists","git_odb_hash","git_odb_new","git_odb_object_close","git_odb_object_data","git_odb_object_id","git_odb_object_size","git_odb_object_type","git_odb_open","git_odb_open_rstream","git_odb_open_wstream","git_odb_read","git_odb_read_header","git_odb_write"]],["oid",["git_oid_allocfmt","git_oid_cmp","git_oid_cpy","git_oid_fmt","git_oid_mkraw","git_oid_mkstr","git_oid_pathfmt","git_oid_shorten_add","git_oid_shorten_free","git_oid_to_string"]],["reference",["git_reference_create_oid","git_reference_create_oid_f","git_reference_create_symbolic","git_reference_create_symbolic_f","git_reference_delete","git_reference_listall","git_reference_listcb","git_reference_lookup","git_reference_name","git_reference_oid","git_reference_owner","git_reference_packall","git_reference_rename","git_reference_rename_f","git_reference_resolve","git_reference_set_oid","git_reference_set_target","git_reference_target","git_reference_type"]],["repository",["git_repository_database","git_repository_free","git_repository_index","git_repository_init","git_repository_is_empty","git_repository_open","git_repository_path","git_repository_workdir"]],["revwalk",["git_revwalk_free","git_revwalk_hide","git_revwalk_new","git_revwalk_next","git_revwalk_push","git_revwalk_repository","git_revwalk_reset","git_revwalk_sorting"]],["signature",["git_signature_dup","git_signature_free","git_signature_new","git_signature_now"]],["strarray",["git_strarray_free"]],["strerror",["git_strerror"]],["tag",["git_tag_close","git_tag_id","git_tag_lookup","git_tag_message","git_tag_name","git_tag_tagger","git_tag_target","git_tag_target_oid","git_tag_type"]],["tree",["git_tree_close","git_tree_create_fromindex","git_tree_entry_attributes","git_tree_entry_byindex","git_tree_entry_byname","git_tree_entry_id","git_tree_entry_name","git_tree_entrycount","git_tree_id","git_tree_lookup"]],["treebuilder",["git_treebuilder_clear","git_treebuilder_create","git_treebuilder_filter","git_treebuilder_free","git_treebuilder_get","git_treebuilder_insert","git_treebuilder_remove","git_treebuilder_write"]]],"functions":{"git_treebuilder_insert":{"comments":"/**\n* Add or update an entry to the builder\n*\n* Insert a new entry for `filename` in the builder with the\n* given attributes.\n*\n* if an entry named `filename` already exists, its attributes\n* will be updated with the given ones.\n*\n* The optional pointer `entry_out` can be used to retrieve a\n* pointer to the newly created/updated entry.\n*\n* @param entry_out Pointer to store the entry (optional)\n* @param bld Tree builder\n* @param filename Filename of the entry\n* @param id SHA1 oid of the entry\n* @param attributes Folder attributes of the entry\n* @return 0 on success; error code otherwise\n*/\n","line":208,"args":"git_tree_entry **entry_out, git_treebuilder *bld, const char *filename, const git_oid *id, unsigned int attributes","return":"GIT_EXTERN(int)"},"git_tag_close":{"comments":"/**\n* Close an open tag\n*\n* This is a wrapper around git_object_close()\n*\n* IMPORTANT:\n* It *is* necessary to call this method when you stop\n* using a tag. Failure to do so will cause a memory leak.\n*\n* @param tag the tag to close\n*/\n","line":55,"args":"git_tag *tag","return":"GIT_INLINE(void)"},"git_treebuilder_write":{"comments":"/**\n* Write the contents of the tree builder as a tree object\n*\n* The tree builder will be written to the given `repo`, and\n* it's identifying SHA1 hash will be stored in the `oid`\n* pointer.\n*\n* @param oid Pointer where to store the written OID\n* @param repo Repository where to store the object\n* @param bld Tree builder to write\n* @return 0 on success; error code otherwise\n*/\n","line":250,"args":"git_oid *oid, git_repository *repo, git_treebuilder *bld","return":"GIT_EXTERN(int)"},"git_tree_entry_attributes":{"comments":"/**\n* Get the UNIX file attributes of a tree entry\n*\n* @param entry a tree entry\n* @return attributes as an integer\n*/\n","line":107,"args":"const git_tree_entry *entry","return":"GIT_EXTERN(unsigned int)"},"git_commit_parentcount":{"comments":"/**\n* Get the number of parents of this commit\n*\n* @param commit a previously loaded commit.\n* @return integer of count of parents\n*/\n","line":148,"args":"git_commit *commit","return":"GIT_EXTERN(unsigned int)"},"git_oid_mkstr":{"comments":"/**\n* Parse a hex formatted object id into a git_oid.\n* @param out oid structure the result is written into.\n* @param str input hex string; must be pointing at the start of\n*        the hex sequence and have at least the number of bytes\n*        needed for an oid encoded in hex (40 bytes).\n* @return GIT_SUCCESS if valid; GIT_ENOTOID on failure.\n*/\n","line":52,"args":"git_oid *out, const char *str","return":"GIT_EXTERN(int)"},"git_reference_create_oid":{"comments":"/**\n* Create a new object id reference.\n*\n* The reference will be created in the repository and written\n* to the disk.\n*\n* This reference is owned by the repository and shall not\n* be free'd by the user.\n*\n* @param ref_out Pointer to the newly created reference\n* @param repo Repository where that reference will live\n* @param name The name of the reference\n* @param id The object id pointed to by the reference.\n* @return 0 on success; error code otherwise\n*/\n","line":92,"args":"git_reference **ref_out, git_repository *repo, const char *name, const git_oid *id","return":"GIT_EXTERN(int)"},"git_tree_lookup":{"comments":"/**\n* Lookup a tree object from the repository.\n*\n* @param tree pointer to the looked up tree\n* @param repo the repo to use when locating the tree.\n* @param id identity of the tree to locate.\n* @return 0 on success; error code otherwise\n*/\n","line":42,"args":"git_tree **tree, git_repository *repo, const git_oid *id","return":"GIT_INLINE(int)"},"git_odb_open":{"comments":"/**\n* Create a new object database and automatically add\n* the two default backends:\n*\n*\t- git_odb_backend_loose: read and write loose object files\n*\t\tfrom disk, assuming `objects_dir` as the Objects folder\n*\n*\t- git_odb_backend_pack: read objects from packfiles,\n*\t\tassuming `objects_dir` as the Objects folder which\n*\t\tcontains a 'pack/' folder with the corresponding data\n*\n* @param out location to store the database pointer, if opened.\n*            Set to NULL if the open failed.\n* @param objects_dir path of the backends' \"objects\" directory.\n* @return GIT_SUCCESS if the database opened; otherwise an error\n*         code describing why the open was not possible.\n*/\n","line":55,"args":"git_odb **out, const char *objects_dir","return":"GIT_EXTERN(int)"},"git_reference_set_target":{"comments":"/**\n* Set the symbolic target of a reference.\n*\n* The reference must be a symbolic reference, otherwise\n* this method will fail.\n*\n* The reference will be automatically updated in\n* memory and on disk.\n*\n* @param ref The reference\n* @param target The new target for the reference\n* @return 0 on success; error code otherwise\n*/\n","line":191,"args":"git_reference *ref, const char *target","return":"GIT_EXTERN(int)"},"git_commit_message":{"comments":"/**\n* Get the full message of a commit.\n*\n* @param commit a previously loaded commit.\n* @return the message of a commit\n*/\n","line":89,"args":"git_commit *commit","return":"GIT_EXTERN(const char *)"},"git_treebuilder_create":{"comments":"/**\n* Create a new tree builder.\n*\n* The tree builder can be used to create or modify\n* trees in memory and write them as tree objects to the\n* database.\n*\n* If the `source` parameter is not NULL, the tree builder\n* will be initialized with the entries of the given tree.\n*\n* If the `source` parameter is NULL, the tree builder will\n* have no entries and will have to be filled manually.\n*\n* @param builder_p Pointer where to store the tree builder\n* @param source Source tree to initialize the builder (optional)\n* @return 0 on sucess; error code otherwise\n*/\n","line":159,"args":"git_treebuilder **builder_p, const git_tree *source","return":"GIT_EXTERN(int)"},"git_commit_time_offset":{"comments":"/**\n* Get the commit timezone offset (i.e. committer's preferred timezone) of a commit.\n*\n* @param commit a previously loaded commit.\n* @return positive or negative timezone offset, in minutes from UTC\n*/\n","line":105,"args":"git_commit *commit","return":"GIT_EXTERN(int)"},"git_revwalk_free":{"comments":"/**\n* Free a revision walker previously allocated.\n*\n* @param walk traversal handle to close.  If NULL nothing occurs.\n*/\n","line":169,"args":"git_revwalk *walk","return":"GIT_EXTERN(void)"},"git_tree_close":{"comments":"/**\n* Close an open tree\n*\n* This is a wrapper around git_object_close()\n*\n* IMPORTANT:\n* It *is* necessary to call this method when you stop\n* using a tree. Failure to do so will cause a memory leak.\n*\n* @param tree the tree to close\n*/\n","line":55,"args":"git_tree *tree","return":"GIT_INLINE(void)"},"git_revwalk_new":{"comments":"/**\n* Allocate a new revision walker to iterate through a repo.\n*\n* This revision walker uses a custom memory pool and an internal\n* commit cache, so it is relatively expensive to allocate.\n*\n* For maximum performance, this revision walker should be\n* reused for different walks.\n*\n* This revision walker is *not* thread safe: it may only be\n* used to walk a repository on a single thread; however,\n* it is possible to have several revision walkers in\n* several different threads walking the same repository.\n*\n* @param walker pointer to the new revision walker\n* @param repo the repo to walk through\n* @return 0 on success; error code otherwise\n*/\n","line":70,"args":"git_revwalk **walker, git_repository *repo","return":"GIT_EXTERN(int)"},"git_signature_new":{"comments":"/**\n* Create a new action signature. The signature must be freed\n* manually or using git_signature_free\n*\n* @param name name of the person\n* @param mail email of the person\n* @param time time when the action happened\n* @param offset timezone offset in minutes for the time\n* @return the new sig, NULL on out of memory\n*/\n","line":40,"args":"const char *name, const char *email, git_time_t time, int offset","return":"GIT_EXTERN(git_signature *)"},"git_oid_cmp":{"comments":"/**\n* Compare two oid structures.\n* @param a first oid structure.\n* @param b second oid structure.\n* @return <0, 0, >0 if a < b, a == b, a > b.\n*/\n","line":127,"args":"const git_oid *a, const git_oid *b","return":"GIT_EXTERN(int)"},"git_signature_dup":{"comments":"/**\n* Create a copy of an existing signature.\n*\n* All internal strings are also duplicated.\n* @param sig signature to duplicated\n* @return a copy of sig, NULL on out of memory\n*/\n","line":63,"args":"const git_signature *sig","return":"GIT_EXTERN(git_signature *)"},"git_tag_name":{"comments":"/**\n* Get the name of a tag\n*\n* @param tag a previously loaded tag.\n* @return name of the tag\n*/\n","line":109,"args":"git_tag *t","return":"GIT_EXTERN(const char *)"},"git_repository_index":{"comments":"/**\n* Get the Index file of a Git repository\n*\n* This is a cheap operation; the index is only opened on the first call,\n* and subsequent calls only retrieve the previous pointer.\n*\n* @param index Pointer where to store the index\n* @param repo a repository object\n* @return 0 on success; error code if the index could not be opened\n*/\n","line":143,"args":"git_index **index, git_repository *repo","return":"GIT_EXTERN(int)"},"git_blob_rawcontent":{"comments":"/**\n* Get a read-only buffer with the raw content of a blob.\n*\n* A pointer to the raw content of a blob is returned;\n* this pointer is owned internally by the object and shall\n* not be free'd. The pointer may be invalidated at a later\n* time.\n*\n* @param blob pointer to the blob\n* @return the pointer; NULL if the blob has no contents\n*/\n","line":73,"args":"git_blob *blob","return":"GIT_EXTERN(const void *)"},"git_object_typeisloose":{"comments":"/**\n* Determine if the given git_otype is a valid loose object type.\n*\n* @param type object type to test.\n* @return true if the type represents a valid loose object type,\n* false otherwise.\n*/\n","line":121,"args":"git_otype type","return":"GIT_EXTERN(int)"},"git_revwalk_repository":{"comments":"/**\n* Return the repository on which this walker\n* is operating.\n*\n* @param walk the revision walker\n* @return the repository being walked\n*/\n","line":176,"args":"git_revwalk *walk","return":"GIT_EXTERN(git_repository *)"},"git_reference_type":{"comments":"/**\n* Get the type of a reference\n*\n* Either direct (GIT_REF_OID) or symbolic (GIT_REF_SYMBOLIC)\n*\n* @param ref The reference\n* @return the type\n*/\n","line":150,"args":"git_reference *ref","return":"GIT_EXTERN(git_rtype)"},"git_odb_add_alternate":{"comments":"/**\n* Add a custom backend to an existing Object DB; this\n* backend will work as an alternate.\n*\n* Alternate backends are always checked for objects *after*\n* all the main backends have been exhausted.\n*\n* Writing is disabled on alternate backends.\n*\n* Read <odb_backends.h> for more information.\n*\n* @param odb database to add the backend to\n* @paramm backend pointer to a git_odb_backend instance\n* @return 0 on sucess; error code otherwise\n*/\n","line":85,"args":"git_odb *odb, git_odb_backend *backend, int priority","return":"GIT_EXTERN(int)"},"git_revwalk_hide":{"comments":"/**\n* Mark a commit (and its ancestors) uninteresting for the output.\n*\n* The given OID must belong to a commit on the walked\n* repository.\n*\n* The resolved commit and all its parents will be hidden from the\n* output on the revision walk.\n*\n* @param walker the walker being used for the traversal.\n* @param commit the commit that will be ignored during the traversal\n* @return 0 on success; error code otherwise\n*/\n","line":123,"args":"git_revwalk *walk, const git_oid *oid","return":"GIT_EXTERN(int)"},"git_strarray_free":{"comments":"/**\n* @file git2/common.h\n* @brief Git common platform definitions\n* @defgroup git_common Git common platform definitions\n* @ingroup Git\n* @{\n*/\n","line":79,"args":"git_strarray *array","return":"GIT_EXTERN(void)"},"git_index_append":{"comments":"/**\n* Add (append) an index entry from a file in disk\n*\n* A new entry will always be inserted into the index;\n* if the index already contains an entry for such\n* path, the old entry will **not** be replaced.\n*\n* The file `path` must be relative to the repository's\n* working folder and must be readable.\n*\n* This method will fail in bare index instances.\n*\n* @param index an existing index object\n* @param path filename to add\n* @param stage stage for the entry\n* @return 0 on success, otherwise an error code\n*/\n","line":201,"args":"git_index *index, const char *path, int stage","return":"GIT_EXTERN(int)"},"git_reference_create_symbolic":{"comments":"/**\n* Create a new symbolic reference.\n*\n* The reference will be created in the repository and written\n* to the disk.\n*\n* This reference is owned by the repository and shall not\n* be free'd by the user.\n*\n* @param ref_out Pointer to the newly created reference\n* @param repo Repository where that reference will live\n* @param name The name of the reference\n* @param target The target of the reference\n* @return 0 on success; error code otherwise\n*/\n","line":54,"args":"git_reference **ref_out, git_repository *repo, const char *name, const char *target","return":"GIT_EXTERN(int)"},"git_object_id":{"comments":"/**\n* Get the id (SHA1) of a repository object\n*\n* @param obj the repository object\n* @return the SHA1 id\n*/\n","line":61,"args":"const git_object *obj","return":"GIT_EXTERN(const git_oid *)"},"git_odb_hash":{"comments":"/**\n* Determine the object-ID (sha1 hash) of a data buffer\n*\n* The resulting SHA-1 OID will the itentifier for the data\n* buffer as if the data buffer it were to written to the ODB.\n*\n* @param id the resulting object-ID.\n* @param data data to hash\n* @param len size of the data\n* @param type of the data to hash\n* @return 0 on success; error code otherwise\n*/\n","line":234,"args":"git_oid *id, const void *data, size_t len, git_otype type","return":"GIT_EXTERN(int)"},"git_object_lookup":{"comments":"/**\n* Lookup a reference to one of the objects in a repostory.\n*\n* The generated reference is owned by the repository and\n* should be closed with the `git_object_close` method\n* instead of free'd manually.\n*\n* The 'type' parameter must match the type of the object\n* in the odb; the method will fail otherwise.\n* The special value 'GIT_OBJ_ANY' may be passed to let\n* the method guess the object's type.\n*\n* @param object pointer to the looked-up object\n* @param repo the repository to look up the object\n* @param id the unique identifier for the object\n* @param type the type of the object\n* @return a reference to the object\n*/\n","line":41,"args":"git_object **object, git_repository *repo, const git_oid *id, git_otype type","return":"GIT_EXTERN(int)"},"git_reference_oid":{"comments":"/**\n* Get the OID pointed to by a reference.\n*\n* Only available if the reference is direct (i.e. not symbolic)\n*\n* @param ref The reference\n* @return a pointer to the oid if available, NULL otherwise\n*/\n","line":130,"args":"git_reference *ref","return":"GIT_EXTERN(const git_oid *)"},"git_oid_shorten_free":{"comments":"/**\n* Free an OID shortener instance\n*\n* @param os a `git_oid_shorten` instance\n*/\n","line":182,"args":"git_oid_shorten *os","return":"void"},"git_odb_object_data":{"comments":"/**\n* Return the data of an ODB object\n*\n* This is the uncompressed, raw data as read from the ODB,\n* without the leading header.\n*\n* This pointer is owned by the object and shall not be free'd.\n*\n* @param object the object\n* @return a pointer to the data\n*/\n","line":268,"args":"git_odb_object *object","return":"GIT_EXTERN(const void *)"},"git_treebuilder_filter":{"comments":"/**\n* Filter the entries in the tree\n*\n* The `filter` callback will be called for each entry\n* in the tree with a pointer to the entry and the\n* provided `payload`: if the callback returns 1, the\n* entry will be filtered (removed from the builder).\n*\n* @param bld Tree builder\n* @param filter Callback to filter entries\n*/\n","line":237,"args":"git_treebuilder *bld, int (*filter)(const git_tree_entry *, void *), void *payload","return":"GIT_EXTERN(void)"},"git_repository_database":{"comments":"/**\n* Get the object database behind a Git repository\n*\n* @param repo a repository object\n* @return a pointer to the object db\n*/\n","line":135,"args":"git_repository *repo","return":"GIT_EXTERN(git_odb *)"},"git_tree_entry_id":{"comments":"/**\n* Get the id of the object pointed by the entry\n*\n* @param entry a tree entry\n* @return the oid of the object\n*/\n","line":123,"args":"const git_tree_entry *entry","return":"GIT_EXTERN(const git_oid *)"},"git_blob_create_fromfile":{"comments":"/**\n* Read a file from the working folder of a repository\n* and write it to the Object Database as a loose blob\n*\n* @param oid return the id of the written blob\n* @param repo repository where the blob will be written.\n*\tthis repository cannot be bare\n* @param path file from which the blob will be created,\n*\trelative to the repository's working dir\n* @return 0 on success; error code otherwise\n*/\n","line":94,"args":"git_oid *oid, git_repository *repo, const char *path","return":"GIT_EXTERN(int)"},"git_tree_entry_byname":{"comments":"/**\n* Lookup a tree entry by its filename\n*\n* @param tree a previously loaded tree.\n* @param filename the filename of the desired entry\n* @return the tree entry; NULL if not found\n*/\n","line":89,"args":"git_tree *tree, const char *filename","return":"GIT_EXTERN(const git_tree_entry *)"},"git_odb_close":{"comments":"/**\n* Close an open object database.\n*\n* @param db database pointer to close.  If NULL no action is taken.\n*/\n","line":102,"args":"git_odb *db","return":"GIT_EXTERN(void)"},"git_reference_create_oid_f":{"comments":"/**\n* Create a new object id reference, overwriting an existing one with\n* the same name, if it exists.\n*\n* If the new reference isn't an object id one, any pointers to the\n* old reference become invalid.\n*\n* The reference will be created in the repository and written\n* to the disk.\n*\n* This reference is owned by the repository and shall not\n* be free'd by the user.\n*\n* @param ref_out Pointer to the newly created reference\n* @param repo Repository where that reference will live\n* @param name The name of the reference\n* @param id The object id pointed to by the reference.\n* @return 0 on success; error code otherwise\n*/\n","line":109,"args":"git_reference **ref_out, git_repository *repo, const char *name, const git_oid *id","return":"GIT_EXTERN(int)"},"git_tag_id":{"comments":"/**\n* Get the id of a tag.\n*\n* @param tag a previously loaded tag.\n* @return object identity for the tag.\n*/\n","line":73,"args":"git_tag *tag","return":"GIT_EXTERN(const git_oid *)"},"git_reference_target":{"comments":"/**\n* Get full name to the reference pointed by this reference\n*\n* Only available if the reference is symbolic\n*\n* @param ref The reference\n* @return a pointer to the name if available, NULL otherwise\n*/\n","line":140,"args":"git_reference *ref","return":"GIT_EXTERN(const char *)"},"git_odb_add_backend":{"comments":"/**\n* Add a custom backend to an existing Object DB\n*\n* Read <odb_backends.h> for more information.\n*\n* @param odb database to add the backend to\n* @paramm backend pointer to a git_odb_backend instance\n* @return 0 on sucess; error code otherwise\n*/\n","line":74,"args":"git_odb *odb, git_odb_backend *backend, int priority","return":"GIT_EXTERN(int)"},"git_object_type":{"comments":"/**\n* Get the object type of an object\n*\n* @param obj the repository object\n* @return the object's type\n*/\n","line":69,"args":"const git_object *obj","return":"GIT_EXTERN(git_otype)"},"git_index_add":{"comments":"/**\n* Add or update an index entry from a file in disk\n*\n* The file `path` must be relative to the repository's\n* working folder and must be readable.\n*\n* This method will fail in bare index instances.\n*\n* @param index an existing index object\n* @param path filename to add\n* @param stage stage for the entry\n* @return 0 on success, otherwise an error code\n*/\n","line":174,"args":"git_index *index, const char *path, int stage","return":"GIT_EXTERN(int)"},"git_treebuilder_clear":{"comments":"/**\n* Clear all the entires in the builder\n*\n* @param bld Builder to clear\n*/\n","line":178,"args":"git_treebuilder *bld","return":"GIT_EXTERN(void)"},"git_index_get":{"comments":"/**\n* Get a pointer to one of the entries in the index\n*\n* This entry can be modified, and the changes will be written\n* back to disk on the next write() call.\n*\n* @param index an existing index object\n* @param n the position of the entry\n* @return a pointer to the entry; NULL if out of bounds\n*/\n","line":247,"args":"git_index *index, int n","return":"GIT_EXTERN(git_index_entry *)"},"git_repository_free":{"comments":"/**\n* Free a previously allocated repository\n*\n* Note that after a repository is free'd, all the objects it has spawned\n* will still exist until they are manually closed by the user\n* with `git_object_close`, but accessing any of the attributes of\n* an object without a backing repository will result in undefined\n* behavior\n*\n* @param repo repository handle to close. If NULL nothing occurs.\n*/\n","line":155,"args":"git_repository *repo","return":"GIT_EXTERN(void)"},"git_oid_cpy":{"comments":"/**\n* Copy an oid from one structure to another.\n* @param out oid structure the result is written into.\n* @param src oid structure to copy from.\n*/\n","line":120,"args":"git_oid *out, const git_oid *src","return":"GIT_EXTERN(void)"},"git_index_open_inrepo":{"comments":"/**\n* Open the Index inside the git repository pointed\n* by 'repo'.\n*\n* @param index the pointer for the new index\n* @param repo the git repo which owns the index\n* @return 0 on success; error code otherwise\n*/\n","line":120,"args":"git_index **index, git_repository *repo","return":"GIT_EXTERN(int)"},"git_treebuilder_get":{"comments":"/**\n* Get an entry from the builder from its filename\n*\n* The returned entry is owned by the builder and should\n* not be freed manually.\n*\n* @param bld Tree builder\n* @param filename Name of the entry\n* @return pointer to the entry; NULL if not found\n*/\n","line":196,"args":"git_treebuilder *bld, const char *filename","return":"GIT_EXTERN(const git_tree_entry *)"},"git_oid_shorten_add":{"comments":"/**\n* Add a new OID to set of shortened OIDs and calculate\n* the minimal length to uniquely identify all the OIDs in\n* the set.\n*\n* The OID is expected to be a 40-char hexadecimal string.\n* The OID is owned by the user and will not be modified\n* or freed.\n*\n* For performance reasons, there is a hard-limit of how many\n* OIDs can be added to a single set (around ~22000, assuming\n* a mostly randomized distribution), which should be enough\n* for any kind of program, and keeps the algorithm fast and\n* memory-efficient.\n*\n* Attempting to add more than those OIDs will result in a\n* GIT_ENOMEM error\n*\n* @param os a `git_oid_shorten` instance\n* @param text_oid an OID in text form\n* @return the minimal length to uniquely identify all OIDs\n*\t\tadded so far to the set; or an error code (<0) if an\n*\t\terror occurs.\n*/\n","line":156,"args":"git_oid_shorten *os, const char *text_oid","return":"int"},"git_blob_close":{"comments":"/**\n* Close an open blob\n*\n* This is a wrapper around git_object_close()\n*\n* IMPORTANT:\n* It *is* necessary to call this method when you stop\n* using a blob. Failure to do so will cause a memory leak.\n*\n* @param blob the blob to close\n*/\n","line":55,"args":"git_blob *blob","return":"GIT_INLINE(void)"},"git_revwalk_next":{"comments":"/**\n* Get the next commit from the revision walk.\n*\n* The initial call to this method is *not* blocking when\n* iterating through a repo with a time-sorting mode.\n*\n* Iterating with Topological or inverted modes makes the initial\n* call blocking to preprocess the commit list, but this block should be\n* mostly unnoticeable on most repositories (topological preprocessing\n* times at 0.3s on the git.git repo).\n*\n* The revision walker is reset when the walk is over.\n*\n* @param oid Pointer where to store the oid of the next commit\n* @param walk the walker to pop the commit from.\n* @return GIT_SUCCESS if the next commit was found;\n*\tGIT_EREVWALKOVER if there are no commits left to iterate\n*/\n","line":138,"args":"git_oid *oid, git_revwalk *walk","return":"GIT_EXTERN(int)"},"git_repository_init":{"comments":"/**\n* Creates a new Git repository in the given folder.\n*\n* TODO:\n*\t- Reinit the repository\n*\t- Create config files\n*\n* @param repo_out pointer to the repo which will be created or reinitialized\n* @param path the path to the repository\n* @param is_bare if true, a Git repository without a working directory is created\n*\t\tat the pointed path. If false, provided path will be considered as the working\n*\t\tdirectory into which the .git directory will be created.\n*\n* @return 0 on success; error code otherwise\n*/\n","line":168,"args":"git_repository **repo_out, const char *path, unsigned is_bare","return":"GIT_EXTERN(int)"},"git_index_clear":{"comments":"/**\n* Clear the contents (all the entries) of an index object.\n* This clears the index object in memory; changes must be manually\n* written to disk for them to take effect.\n*\n* @param index an existing index object\n*/\n","line":130,"args":"git_index *index","return":"GIT_EXTERN(void)"},"git_repository_workdir":{"comments":"/**\n* Get the normalized path to the working directory of the repository.\n*\n* If the repository is bare, there is no working directory and NULL we be returned.\n*\n* @param repo a repository object\n* @return NULL if the repository is bare; absolute path to the working directory otherwise.\n*/\n","line":205,"args":"git_repository *repo","return":"GIT_EXTERN(const char *)"},"git_treebuilder_remove":{"comments":"/**\n* Remove an entry from the builder by its filename\n*\n* @param bld Tree builder\n* @param filename Filename of the entry to remove\n*/\n","line":229,"args":"git_treebuilder *bld, const char *filename","return":"GIT_EXTERN(int)"},"git_tree_entrycount":{"comments":"/**\n* Get the number of entries listed in a tree\n*\n* @param tree a previously loaded tree.\n* @return the number of entries in the tree\n*/\n","line":81,"args":"git_tree *tree","return":"GIT_EXTERN(size_t)"},"git_commit_time":{"comments":"/**\n* Get the commit time (i.e. committer time) of a commit.\n*\n* @param commit a previously loaded commit.\n* @return the time of a commit\n*/\n","line":97,"args":"git_commit *commit","return":"GIT_EXTERN(git_time_t)"},"git_index_free":{"comments":"/**\n* Free an existing index object.\n*\n* @param index an existing index object\n*/\n","line":139,"args":"git_index *index","return":"GIT_EXTERN(void)"},"git_index_write":{"comments":"/**\n* Write an existing index object from memory back to disk\n* using an atomic file lock.\n*\n* @param index an existing index object\n* @return 0 on success, otherwise an error code\n*/\n","line":155,"args":"git_index *index","return":"GIT_EXTERN(int)"},"git_tag_target":{"comments":"/**\n* Get the tagged object of a tag\n*\n* This method performs a repository lookup for the\n* given object and returns it\n*\n* @param target pointer where to store the target\n* @param tag a previously loaded tag.\n* @return 0 on success; error code otherwise\n*/\n","line":81,"args":"git_object **target, git_tag *t","return":"GIT_EXTERN(int)"},"git_odb_object_id":{"comments":"/**\n* Return the OID of an ODB object\n*\n* This is the OID from which the object was read from\n*\n* @param object the object\n* @return a pointer to the OID\n*/\n","line":258,"args":"git_odb_object *object","return":"GIT_EXTERN(const git_oid *)"},"git_revwalk_push":{"comments":"/**\n* Mark a commit to start traversal from.\n*\n* The given OID must belong to a commit on the walked\n* repository.\n*\n* The given commit will be used as one of the roots\n* when starting the revision walk. At least one commit\n* must be pushed the repository before a walk can\n* be started.\n*\n* @param walker the walker being used for the traversal.\n* @param oid the oid of the commit to start from.\n* @return 0 on success; error code otherwise\n*/\n","line":105,"args":"git_revwalk *walk, const git_oid *oid","return":"GIT_EXTERN(int)"},"git_blob_lookup":{"comments":"/**\n* Lookup a blob object from a repository.\n*\n* @param blob pointer to the looked up blob\n* @param repo the repo to use when locating the blob.\n* @param id identity of the blob to locate.\n* @return 0 on success; error code otherwise\n*/\n","line":42,"args":"git_blob **blob, git_repository *repo, const git_oid *id","return":"GIT_INLINE(int)"},"git_tag_tagger":{"comments":"/**\n* Get the tagger (author) of a tag\n*\n* @param tag a previously loaded tag.\n* @return reference to the tag's author\n*/\n","line":117,"args":"git_tag *t","return":"GIT_EXTERN(const git_signature *)"},"git_odb_new":{"comments":"/**\n* Create a new object database with no backends.\n*\n* Before the ODB can be used for read/writing, a custom database\n* backend must be manually added using `git_odb_add_backend()`\n*\n* @param out location to store the database pointer, if opened.\n*            Set to NULL if the open failed.\n* @return GIT_SUCCESS if the database was created; otherwise an error\n*         code describing why the open was not possible.\n*/\n","line":42,"args":"git_odb **out","return":"GIT_EXTERN(int)"},"git_commit_tree":{"comments":"/**\n* Get the tree pointed to by a commit.\n*\n* @param tree_out pointer where to store the tree object\n* @param commit a previously loaded commit.\n* @return 0 on success; error code otherwise\n*/\n","line":129,"args":"git_tree **tree_out, git_commit *commit","return":"GIT_EXTERN(int)"},"git_oid_allocfmt":{"comments":"/**\n* Format a gid_oid into a newly allocated c-string.\n* @param oid the oid structure to format\n* @return the c-string; NULL if memory is exhausted.  Caller must\n*         deallocate the string with free().\n*/\n","line":95,"args":"const git_oid *oid","return":"GIT_EXTERN(char *)"},"git_treebuilder_free":{"comments":"/**\n* Free a tree builder\n*\n* This will clear all the entries and free to builder.\n* Failing to free the builder after you're done using it\n* will result in a memory leak\n*\n* @param bld Builder to free\n*/\n","line":185,"args":"git_treebuilder *bld","return":"GIT_EXTERN(void)"},"git_tree_create_fromindex":{"comments":"/**\n* Write a tree to the ODB from the index file\n*\n* This method will scan the index and write a representation\n* of its current state back to disk; it recursively creates\n* tree objects for each of the subtrees stored in the index,\n* but only returns the OID of the root tree. This is the OID\n* that can be used e.g. to create a commit.\n*\n* The index instance cannot be bare, and needs to be associated\n* to an existing repository.\n*\n* @param oid Pointer where to store the written tree\n* @param index Index to write\n* @return 0 on success; error code otherwise\n*/\n","line":141,"args":"git_oid *oid, git_index *index","return":"GIT_EXTERN(int)"},"git_reference_lookup":{"comments":"/**\n* Lookup a reference by its name in a repository.\n*\n* The generated reference is owned by the repository and\n* should not be freed by the user.\n*\n* @param reference_out pointer to the looked-up reference\n* @param repo the repository to look up the reference\n* @param name the long name for the reference (e.g. HEAD, ref/heads/master, refs/tags/v0.1.0, ...)\n* @return 0 on success; error code otherwise\n*/\n","line":41,"args":"git_reference **reference_out, git_repository *repo, const char *name","return":"GIT_EXTERN(int)"},"git_odb_open_rstream":{"comments":"/**\n* Open a stream to read an object from the ODB\n*\n* Note that most backends do *not* support streaming reads\n* because they store their objects as compressed/delta'ed blobs.\n*\n* It's recommended to use `git_odb_read` instead, which is\n* assured to work on all backends.\n*\n* The returned stream will be of type `GIT_STREAM_RDONLY` and\n* will have the following methods:\n*\n*\t\t- stream->read: read `n` bytes from the stream\n*\t\t- stream->free: free the stream\n*\n* The stream must always be free'd or will leak memory.\n*\n* @see git_odb_stream\n*\n* @param stream pointer where to store the stream\n* @param db object database where the stream will read from\n* @param oid oid of the object the stream will read from\n* @return 0 if the stream was created; error code otherwise\n*/\n","line":208,"args":"git_odb_stream **stream, git_odb *db, const git_oid *oid","return":"GIT_EXTERN(int)"},"git_commit_committer":{"comments":"/**\n* Get the committer of a commit.\n*\n* @param commit a previously loaded commit.\n* @return the committer of a commit\n*/\n","line":113,"args":"git_commit *commit","return":"GIT_EXTERN(const git_signature *)"},"git_reference_resolve":{"comments":"/**\n* Resolve a symbolic reference\n*\n* Thie method iteratively peels a symbolic reference\n* until it resolves to a direct reference to an OID.\n*\n* If a direct reference is passed as an argument,\n* that reference is returned immediately\n*\n* @param resolved_ref Pointer to the peeled reference\n* @param ref The reference\n* @return 0 on success; error code otherwise\n*/\n","line":168,"args":"git_reference **resolved_ref, git_reference *ref","return":"GIT_EXTERN(int)"},"git_reference_name":{"comments":"/**\n* Get the full name of a reference\n*\n* @param ref The reference\n* @return the full name for the ref\n*/\n","line":160,"args":"git_reference *ref","return":"GIT_EXTERN(const char *)"},"git_odb_exists":{"comments":"/**\n* Determine if the given object can be found in the object database.\n*\n* @param db database to be searched for the given object.\n* @param id the object to search for.\n* @return\n* - 1, if the object was found\n* - 0, otherwise\n*/\n","line":148,"args":"git_odb *db, const git_oid *id","return":"GIT_EXTERN(int)"},"git_reference_create_symbolic_f":{"comments":"/**\n* Create a new symbolic reference, overwriting an existing one with\n* the same name, if it exists.\n*\n* If the new reference isn't a symbolic one, any pointers to the old\n* reference become invalid.\n*\n* The reference will be created in the repository and written\n* to the disk.\n*\n* This reference is owned by the repository and shall not\n* be free'd by the user.\n*\n* @param ref_out Pointer to the newly created reference\n* @param repo Repository where that reference will live\n* @param name The name of the reference\n* @param target The target of the reference\n* @return 0 on success; error code otherwise\n*/\n","line":71,"args":"git_reference **ref_out, git_repository *repo, const char *name, const char *target","return":"GIT_EXTERN(int)"},"git_tag_message":{"comments":"/**\n* Get the message of a tag\n*\n* @param tag a previously loaded tag.\n* @return message of the tag\n*/\n","line":125,"args":"git_tag *t","return":"GIT_EXTERN(const char *)"},"git_signature_now":{"comments":"/**\n* Create a new action signature with a timestamp of 'now'. The\n* signature must be freed manually or using git_signature_free\n*\n* @param name name of the person\n* @param email email of the person\n* @return the new sig, NULL on out of memory\n*/\n","line":52,"args":"const char *name, const char *email","return":"GIT_EXTERN(git_signature *)"},"git_reference_owner":{"comments":"/**\n* Get the repository where a reference resides\n*\n* @param ref The reference\n* @return a pointer to the repo\n*/\n","line":183,"args":"git_reference *ref","return":"GIT_EXTERN(git_repository *)"},"git_reference_packall":{"comments":"/**\n* Pack all the loose references in the repository\n*\n* This method will load into the cache all the loose\n* references on the repository and update the\n* `packed-refs` file with them.\n*\n* Once the `packed-refs` file has been written properly,\n* the loose references will be removed from disk.\n*\n* WARNING: calling this method may invalidate any existing\n* references previously loaded on the cache.\n*\n* @param repo Repository where the loose refs will be packed\n* @return 0 on success; error code otherwise\n*/\n","line":259,"args":"git_repository *repo","return":"GIT_EXTERN(int)"},"git_strerror":{"comments":"/**\n* strerror() for the Git library\n*\n* Get a string description for a given error code.\n* NOTE: This method will be eventually deprecated in favor\n* of the new `git_lasterror`.\n*\n* @param num The error code to explain\n* @return a string explaining the error code\n*/\n","line":135,"args":"int num","return":"GIT_EXTERN(const char *)"},"git_oid_pathfmt":{"comments":"/**\n* Format a git_oid into a loose-object path string.\n* <p>\n* The resulting string is \"aa/...\", where \"aa\" is the first two\n* hex digitis of the oid and \"...\" is the remaining 38 digits.\n*\n* @param str output hex string; must be pointing at the start of\n*        the hex sequence and have at least the number of bytes\n*        needed for an oid encoded in hex (41 bytes).  Only the\n*        oid digits are written; a '\\\\0' terminator must be added\n*        by the caller if it is required.\n* @param oid oid structure to format.\n*/\n","line":80,"args":"char *str, const git_oid *oid","return":"GIT_EXTERN(void)"},"git_index_remove":{"comments":"/**\n* Remove an entry from the index\n*\n* @param index an existing index object\n* @param position position of the entry to remove\n* @return 0 on success, otherwise an error code\n*/\n","line":237,"args":"git_index *index, int position","return":"GIT_EXTERN(int)"},"git_blob_rawsize":{"comments":"/**\n* Get the size in bytes of the contents of a blob\n*\n* @param blob pointer to the blob\n* @return size on bytes\n*/\n","line":86,"args":"git_blob *blob","return":"GIT_EXTERN(int)"},"git_revwalk_sorting":{"comments":"/**\n* Change the sorting mode when iterating through the\n* repository's contents.\n*\n* Changing the sorting mode resets the walker.\n*\n* @param walk the walker being used for the traversal.\n* @param sort_mode combination of GIT_SORT_XXX flags\n*/\n","line":158,"args":"git_revwalk *walk, unsigned int sort_mode","return":"GIT_EXTERN(void)"},"git_odb_backend_pack":{"comments":"* Streaming mode ","line":93,"args":"git_odb_backend **backend_out, const char *objects_dir","return":"GIT_EXTERN(int)"},"git_commit_close":{"comments":"/**\n* Close an open commit\n*\n* This is a wrapper around git_object_close()\n*\n* IMPORTANT:\n* It *is* necessary to call this method when you stop\n* using a commit. Failure to do so will cause a memory leak.\n*\n* @param commit the commit to close\n*/\n","line":56,"args":"git_commit *commit","return":"GIT_INLINE(void)"},"git_reference_rename_f":{"comments":"/**\n* Rename an existing reference, overwriting an existing one with the\n* same name, if it exists.\n*\n* This method works for both direct and symbolic references.\n* The new name will be checked for validity and may be\n* modified into a normalized form.\n*\n* The refernece will be immediately renamed in-memory\n* and on disk.\n*\n*/\n","line":234,"args":"git_reference *ref, const char *new_name","return":"GIT_EXTERN(int)"},"git_tree_entry_byindex":{"comments":"/**\n* Lookup a tree entry by its position in the tree\n*\n* @param tree a previously loaded tree.\n* @param idx the position in the entry list\n* @return the tree entry; NULL if not found\n*/\n","line":98,"args":"git_tree *tree, int idx","return":"GIT_EXTERN(const git_tree_entry *)"},"git_tree_id":{"comments":"/**\n* Get the id of a tree.\n*\n* @param tree a previously loaded tree.\n* @return object identity for the tree.\n*/\n","line":73,"args":"git_tree *tree","return":"GIT_EXTERN(const git_oid *)"},"git_commit_parent":{"comments":"/**\n* Get the specified parent of the commit.\n*\n* @param parent Pointer where to store the parent commit\n* @param commit a previously loaded commit.\n* @param n the position of the parent (from 0 to `parentcount`)\n* @return 0 on success; error code otherwise\n*/\n","line":156,"args":"git_commit **parent, git_commit *commit, unsigned int n","return":"GIT_EXTERN(int)"},"git_tag_lookup":{"comments":"/**\n* Lookup a tag object from the repository.\n*\n* @param tag pointer to the looked up tag\n* @param repo the repo to use when locating the tag.\n* @param id identity of the tag to locate.\n* @return 0 on success; error code otherwise\n*/\n","line":42,"args":"git_tag **tag, git_repository *repo, const git_oid *id","return":"GIT_INLINE(int)"},"git_commit_id":{"comments":"/**\n* Get the id of a commit.\n*\n* @param commit a previously loaded commit.\n* @return object identity for the commit.\n*/\n","line":73,"args":"git_commit *commit","return":"GIT_EXTERN(const git_oid *)"},"git_index_find":{"comments":"/**\n* Find the first index of any entries which point to given\n* path in the Git index.\n*\n* @param index an existing index object\n* @param path path to search\n* @return an index >= 0 if found, -1 otherwise\n*/\n","line":164,"args":"git_index *index, const char *path","return":"GIT_EXTERN(int)"},"git_lasterror":{"comments":"/**\n* Return a detailed error string with the latest error\n* that occurred in the library.\n* @return a string explaining the error\n*/\n","line":128,"args":"void","return":"GIT_EXTERN(const char *)"},"git_commit_parent_oid":{"comments":"/**\n* Get the oid of a specified parent for a commit. This is different from\n* `git_commit_parent`, which will attempt to load the parent commit from\n* the ODB.\n*\n* @param commit a previously loaded commit.\n* @param n the position of the parent (from 0 to `parentcount`)\n* @return the id of the parent, NULL on error.\n*/\n","line":166,"args":"git_commit *commit, unsigned int n","return":"GIT_EXTERN(const git_oid *)"},"git_odb_read_header":{"comments":"/**\n* Read the header of an object from the database, without\n* reading its full contents.\n*\n* The header includes the length and the type of an object.\n*\n* Note that most backends do not support reading only the header\n* of an object, so the whole object will be read and then the\n* header will be returned.\n*\n* @param len_p pointer where to store the length\n* @param type_p pointer where to store the type\n* @param db database to search for the object in.\n* @param id identity of the object to read.\n* @return\n* - GIT_SUCCESS if the object was read;\n* - GIT_ENOTFOUND if the object is not in the database.\n*/\n","line":128,"args":"size_t *len_p, git_otype *type_p, git_odb *db, const git_oid *id","return":"GIT_EXTERN(int)"},"git_tag_target_oid":{"comments":"/**\n* Get the OID of the tagged object of a tag\n*\n* @param tag a previously loaded tag.\n* @return pointer to the OID\n*/\n","line":93,"args":"git_tag *t","return":"GIT_EXTERN(const git_oid *)"},"git_repository_open":{"comments":"/**\n* Open a git repository.\n*\n* The 'path' argument must point to an existing git repository\n* folder, e.g.\n*\n*\t\t/path/to/my_repo/.git/\t(normal repository)\n*\t\t\t\t\t\t\tobjects/\n*\t\t\t\t\t\t\tindex\n*\t\t\t\t\t\t\tHEAD\n*\n*\t\t/path/to/bare_repo/\t\t(bare repository)\n*\t\t\t\t\t\tobjects/\n*\t\t\t\t\t\tindex\n*\t\t\t\t\t\tHEAD\n*\n*\tThe method will automatically detect if 'path' is a normal\n*\tor bare repository or fail is 'path' is neither.\n*\n* @param repository pointer to the repo which will be opened\n* @param path the path to the repository\n* @return 0 on success; error code otherwise\n*/\n","line":41,"args":"git_repository **repository, const char *path","return":"GIT_EXTERN(int)"},"git_index_read":{"comments":"/**\n* Update the contents of an existing index object in memory\n* by reading from the hard disk.\n*\n* @param index an existing index object\n* @return 0 on success, otherwise an error code\n*/\n","line":146,"args":"git_index *index","return":"GIT_EXTERN(int)"},"git_signature_free":{"comments":"/**\n* Free an existing signature\n*\n* @param sig signature to free\n*/\n","line":72,"args":"git_signature *sig","return":"GIT_EXTERN(void)"},"git_commit_author":{"comments":"/**\n* Get the author of a commit.\n*\n* @param commit a previously loaded commit.\n* @return the author of a commit\n*/\n","line":121,"args":"git_commit *commit","return":"GIT_EXTERN(const git_signature *)"},"git_odb_write":{"comments":"/**\n* Write an object directly into the ODB\n*\n* This method writes a full object straight into the ODB.\n* For most cases, it is preferred to write objects through a write\n* stream, which is both faster and less memory intensive, specially\n* for big objects.\n*\n* This method is provided for compatibility with custom backends\n* which are not able to support streaming writes\n*\n* @param oid pointer to store the OID result of the write\n* @param odb object database where to store the object\n* @param data buffer with the data to storr\n* @param len size of the buffer\n* @param type type of the data to store\n* @return 0 on success; error code otherwise\n*/\n","line":159,"args":"git_oid *oid, git_odb *odb, const void *data, size_t len, git_otype type","return":"GIT_EXTERN(int)"},"git_reference_listall":{"comments":"/**\n* Fill a list with all the references that can be found\n* in a repository.\n*\n* The listed references may be filtered by type, or using\n* a bitwise OR of several types. Use the magic value\n* `GIT_REF_LISTALL` to obtain all references, including\n* packed ones.\n*\n* The string array will be filled with the names of all\n* references; these values are owned by the user and\n* should be free'd manually when no longer needed, using\n* `git_strarray_free`.\n*\n* @param array Pointer to a git_strarray structure where\n*\t\tthe reference names will be stored\n* @param repo Repository where to find the refs\n* @param list_flags Filtering flags for the reference\n*\t\tlisting.\n* @return 0 on success; error code otherwise\n*/\n","line":277,"args":"git_strarray *array, git_repository *repo, unsigned int list_flags","return":"GIT_EXTERN(int)"},"git_odb_open_wstream":{"comments":"/**\n* Open a stream to write an object into the ODB\n*\n* The type and final length of the object must be specified\n* when opening the stream.\n*\n* The returned stream will be of type `GIT_STREAM_WRONLY` and\n* will have the following methods:\n*\n*\t\t- stream->write: write `n` bytes into the stream\n*\t\t- stream->finalize_write: close the stream and store the object in\n*\t\t\tthe odb\n*\t\t- stream->free: free the stream\n*\n* The streaming write won't be effective until `stream->finalize_write`\n* is called and returns without an error\n*\n* The stream must always be free'd or will leak memory.\n*\n* @see git_odb_stream\n*\n* @param stream pointer where to store the stream\n* @param db object database where the stream will write\n* @param size final size of the object that will be written\n* @param type type of the object that will be written\n* @return 0 if the stream was created; error code otherwise\n*/\n","line":179,"args":"git_odb_stream **stream, git_odb *db, size_t size, git_otype type","return":"GIT_EXTERN(int)"},"git_repository_path":{"comments":"/**\n* Get the normalized path to the git repository.\n*\n* @param repo a repository object\n* @return absolute path to the git directory\n*/\n","line":197,"args":"git_repository *repo","return":"GIT_EXTERN(const char *)"},"git_tag_type":{"comments":"/**\n* Get the type of a tag's tagged object\n*\n* @param tag a previously loaded tag.\n* @return type of the tagged object\n*/\n","line":101,"args":"git_tag *t","return":"GIT_EXTERN(git_otype)"},"git_odb_read":{"comments":"/**\n* Read an object from the database.\n*\n* This method queries all avaiable ODB backends\n* trying to read the given OID.\n*\n* The returned object is reference counted and\n* internally cached, so it should be closed\n* by the user once it's no longer in use.\n*\n* @param out pointer where to store the read object\n* @param db database to search for the object in.\n* @param id identity of the object to read.\n* @return\n* - GIT_SUCCESS if the object was read;\n* - GIT_ENOTFOUND if the object is not in the database.\n*/\n","line":109,"args":"git_odb_object **out, git_odb *db, const git_oid *id","return":"GIT_EXTERN(int)"},"git_reference_set_oid":{"comments":"/**\n* Set the OID target of a reference.\n*\n* The reference must be a direct reference, otherwise\n* this method will fail.\n*\n* The reference will be automatically updated in\n* memory and on disk.\n*\n* @param ref The reference\n* @param target The new target OID for the reference\n* @return 0 on success; error code otherwise\n*/\n","line":206,"args":"git_reference *ref, const git_oid *id","return":"GIT_EXTERN(int)"},"git_index_open_bare":{"comments":"/**\n* Create a new Git index object as a memory representation\n* of the Git index file in 'index_path', without a repository\n* to back it.\n*\n* Since there is no ODB behind this index, any Index methods\n* which rely on the ODB (e.g. index_add) will fail with the\n* GIT_EBAREINDEX error code.\n*\n* @param index the pointer for the new index\n* @param index_path the path to the index file in disk\n* @return 0 on success; error code otherwise\n*/\n","line":105,"args":"git_index **index, const char *index_path","return":"GIT_EXTERN(int)"},"git_tree_entry_name":{"comments":"/**\n* Get the filename of a tree entry\n*\n* @param entry a tree entry\n* @return the name of the file\n*/\n","line":115,"args":"const git_tree_entry *entry","return":"GIT_EXTERN(const char *)"},"git_object__size":{"comments":"/**\n* Get the size in bytes for the structure which\n* acts as an in-memory representation of any given\n* object type.\n*\n* For all the core types, this would the equivalent\n* of calling `sizeof(git_commit)` if the core types\n* were not opaque on the external API.\n*\n* @param type object type to get its size\n* @return size in bytes of the object\n*/\n","line":130,"args":"git_otype type","return":"GIT_EXTERN(size_t)"},"git_commit_lookup":{"comments":"/**\n* Lookup a commit object from a repository.\n*\n* @param commit pointer to the looked up commit\n* @param repo the repo to use when locating the commit.\n* @param id identity of the commit to locate.  If the object is\n*        an annotated tag it will be peeled back to the commit.\n* @return 0 on success; error code otherwise\n*/\n","line":42,"args":"git_commit **commit, git_repository *repo, const git_oid *id","return":"GIT_INLINE(int)"},"git_reference_listcb":{"comments":"/**\n* List all the references in the repository, calling a custom\n* callback for each one.\n*\n* The listed references may be filtered by type, or using\n* a bitwise OR of several types. Use the magic value\n* `GIT_REF_LISTALL` to obtain all references, including\n* packed ones.\n*\n* The `callback` function will be called for each of the references\n* in the repository, and will receive the name of the reference and\n* the `payload` value passed to this method.\n*\n* @param repo Repository where to find the refs\n* @param list_flags Filtering flags for the reference\n*\t\tlisting.\n* @param callback Function which will be called for every listed ref\n* @param payload Additional data to pass to the callback\n* @return 0 on success; error code otherwise\n*/\n","line":301,"args":"git_repository *repo, unsigned int list_flags, int (*callback)(const char *, void *), void *payload","return":"GIT_EXTERN(int)"},"git_object_owner":{"comments":"/**\n* Get the repository that owns this object\n*\n* @param obj the object\n* @return the repository who owns this object\n*/\n","line":77,"args":"const git_object *obj","return":"GIT_EXTERN(git_repository *)"},"git_oid_fmt":{"comments":"/**\n* Format a git_oid into a hex string.\n* @param str output hex string; must be pointing at the start of\n*        the hex sequence and have at least the number of bytes\n*        needed for an oid encoded in hex (40 bytes).  Only the\n*        oid digits are written; a '\\\\0' terminator must be added\n*        by the caller if it is required.\n* @param oid oid structure to format.\n*/\n","line":69,"args":"char *str, const git_oid *oid","return":"GIT_EXTERN(void)"},"git_commit_message_short":{"comments":"/**\n* Get the short (one line) message of a commit.\n*\n* @param commit a previously loaded commit.\n* @return the short message of a commit\n*/\n","line":81,"args":"git_commit *commit","return":"GIT_EXTERN(const char *)"},"git_commit_tree_oid":{"comments":"/**\n* Get the id of the tree pointed to by a commit. This differs from\n* `git_commit_tree` in that no attempts are made to fetch an object\n* from the ODB.\n*\n* @param commit a previously loaded commit.\n* @return the id of tree pointed to by commit.\n*/\n","line":138,"args":"git_commit *commit","return":"GIT_EXTERN(const git_oid *)"},"git_repository_is_empty":{"comments":"/**\n* Check if a repository is empty\n*\n* An empty repository has just been initialized and contains\n* no commits.\n*\n* @param repo Repo to test\n* @return 1 if the repository is empty, 0 if it isn't, error code\n* if the repository is corrupted\n*/\n","line":185,"args":"git_repository *repo","return":"GIT_EXTERN(int)"},"git_reference_delete":{"comments":"/**\n* Delete an existing reference\n*\n* This method works for both direct and symbolic references.\n*\n* The reference will be immediately removed on disk and from\n* memory. The given reference pointer will no longer be valid.\n*\n*/\n","line":248,"args":"git_reference *ref","return":"GIT_EXTERN(int)"},"git_odb_object_type":{"comments":"/**\n* Return the type of an ODB object\n*\n* @param object the object\n* @return the type\n*/\n","line":292,"args":"git_odb_object *object","return":"GIT_EXTERN(git_otype)"},"git_odb_object_size":{"comments":"/**\n* Return the size of an ODB object\n*\n* This is the real size of the `data` buffer, not the\n* actual size of the object.\n*\n* @param object the object\n* @return the size\n*/\n","line":281,"args":"git_odb_object *object","return":"GIT_EXTERN(size_t)"},"git_odb_object_close":{"comments":"/**\n* Close an ODB object\n*\n* This method must always be called once a `git_odb_object` is no\n* longer needed, otherwise memory will leak.\n*\n* @param object object to close\n*/\n","line":248,"args":"git_odb_object *object","return":"GIT_EXTERN(void)"},"git_blob_create_frombuffer":{"comments":"/**\n* Write an in-memory buffer to the ODB as a blob\n*\n* @param oid return the oid of the written blob\n* @param repo repository where to blob will be written\n* @param buffer data to be written into the blob\n* @param len length of the data\n* @return 0 on success; error code otherwise\n*/\n","line":108,"args":"git_oid *oid, git_repository *repo, const void *buffer, size_t len","return":"GIT_EXTERN(int)"},"git_oid_to_string":{"comments":"/**\n* Format a git_oid into a buffer as a hex format c-string.\n* <p>\n* If the buffer is smaller than GIT_OID_HEXSZ+1, then the resulting\n* oid c-string will be truncated to n-1 characters. If there are\n* any input parameter errors (out == NULL, n == 0, oid == NULL),\n* then a pointer to an empty string is returned, so that the return\n* value can always be printed.\n*\n* @param out the buffer into which the oid string is output.\n* @param n the size of the out buffer.\n* @param oid the oid structure to format.\n* @return the out buffer pointer, assuming no input parameter\n*         errors, otherwise a pointer to an empty string.\n*/\n","line":103,"args":"char *out, size_t n, const git_oid *oid","return":"GIT_EXTERN(char *)"},"git_index_entrycount":{"comments":"/**\n* Get the count of entries currently in the index\n*\n* @param index an existing index object\n* @return integer of count of current entries\n*/\n","line":259,"args":"git_index *index","return":"GIT_EXTERN(unsigned int)"},"git_oid_mkraw":{"comments":"/**\n* Copy an already raw oid into a git_oid structure.\n* @param out oid structure the result is written into.\n* @param raw the raw input bytes to be copied.\n*/\n","line":62,"args":"git_oid *out, const unsigned char *raw","return":"GIT_EXTERN(void)"},"git_reference_rename":{"comments":"/**\n* Rename an existing reference\n*\n* This method works for both direct and symbolic references.\n* The new name will be checked for validity and may be\n* modified into a normalized form.\n*\n* The refernece will be immediately renamed in-memory\n* and on disk.\n*\n*/\n","line":221,"args":"git_reference *ref, const char *new_name","return":"GIT_EXTERN(int)"},"git_revwalk_reset":{"comments":"/**\n* Reset the revision walker for reuse.\n*\n* This will clear all the pushed and hidden commits, and\n* leave the walker in a blank state (just like at\n* creation) ready to receive new commit pushes and\n* start a new walk.\n*\n* The revision walk is automatically reset when a walk\n* is over.\n*\n* @param walker handle to reset.\n*/\n","line":90,"args":"git_revwalk *walker","return":"GIT_EXTERN(void)"},"git_object_close":{"comments":"/**\n* Close an open object\n*\n* This method instructs the library to close an existing\n* object; note that git_objects are owned and cached by the repository\n* so the object may or may not be freed after this library call,\n* depending on how agressive is the caching mechanism used\n* by the repository.\n*\n* IMPORTANT:\n* It *is* necessary to call this method when you stop using\n* an object. Failure to do so will cause a memory leak.\n*\n* @param object the object to close\n*/\n","line":85,"args":"git_object *object","return":"GIT_EXTERN(void)"}}}