{"files":[{"file":"blob.h","functions":[{"line":42,"comments":["/**","* Lookup a blob object from a repository.","*","* @param blob pointer to the looked up blob","* @param repo the repo to use when locating the blob.","* @param id identity of the blob to locate.","* @return 0 on success; error code otherwise","*/"],"args":"git_blob **blob, git_repository *repo, const git_oid *id","return":"GIT_INLINE(int)","function":"git_blob_lookup"},{"line":55,"comments":["/**","* Close an open blob","*","* This is a wrapper around git_object_close()","*","* IMPORTANT:","* It *is* necessary to call this method when you stop","* using a blob. Failure to do so will cause a memory leak.","*","* @param blob the blob to close","*/"],"args":"git_blob *blob","return":"GIT_INLINE(void)","function":"git_blob_close"},{"line":73,"comments":["/**","* Get a read-only buffer with the raw content of a blob.","*","* A pointer to the raw content of a blob is returned;","* this pointer is owned internally by the object and shall","* not be free'd. The pointer may be invalidated at a later","* time.","*","* @param blob pointer to the blob","* @return the pointer; NULL if the blob has no contents","*/"],"args":"git_blob *blob","return":"GIT_EXTERN(const void *)","function":"git_blob_rawcontent"},{"line":86,"comments":["/**","* Get the size in bytes of the contents of a blob","*","* @param blob pointer to the blob","* @return size on bytes","*/"],"args":"git_blob *blob","return":"GIT_EXTERN(int)","function":"git_blob_rawsize"},{"line":94,"comments":["/**","* Read a file from the working folder of a repository","* and write it to the Object Database as a loose blob","*","* @param oid return the id of the written blob","* @param repo repository where the blob will be written.","*\tthis repository cannot be bare","* @param path file from which the blob will be created,","*\trelative to the repository's working dir","* @return 0 on success; error code otherwise","*/"],"args":"git_oid *oid, git_repository *repo, const char *path","return":"GIT_EXTERN(int)","function":"git_blob_create_fromfile"},{"line":108,"comments":["/**","* Write an in-memory buffer to the ODB as a blob","*","* @param oid return the oid of the written blob","* @param repo repository where to blob will be written","* @param buffer data to be written into the blob","* @param len length of the data","* @return 0 on success; error code otherwise","*/"],"args":"git_oid *oid, git_repository *repo, const void *buffer, size_t len","return":"GIT_EXTERN(int)","function":"git_blob_create_frombuffer"}],"meta":{"file":"git2/blob.h","brief":"Git blob load and write routines","defgroup":"git_blob Git blob load and write routines","ingroup":"Git"}},{"file":"commit.h","functions":[{"line":42,"comments":["/**","* Lookup a commit object from a repository.","*","* @param commit pointer to the looked up commit","* @param repo the repo to use when locating the commit.","* @param id identity of the commit to locate.  If the object is","*        an annotated tag it will be peeled back to the commit.","* @return 0 on success; error code otherwise","*/"],"args":"git_commit **commit, git_repository *repo, const git_oid *id","return":"GIT_INLINE(int)","function":"git_commit_lookup"},{"line":56,"comments":["/**","* Close an open commit","*","* This is a wrapper around git_object_close()","*","* IMPORTANT:","* It *is* necessary to call this method when you stop","* using a commit. Failure to do so will cause a memory leak.","*","* @param commit the commit to close","*/"],"args":"git_commit *commit","return":"GIT_INLINE(void)","function":"git_commit_close"},{"line":73,"comments":["/**","* Get the id of a commit.","*","* @param commit a previously loaded commit.","* @return object identity for the commit.","*/"],"args":"git_commit *commit","return":"GIT_EXTERN(const git_oid *)","function":"git_commit_id"},{"line":81,"comments":["/**","* Get the short (one line) message of a commit.","*","* @param commit a previously loaded commit.","* @return the short message of a commit","*/"],"args":"git_commit *commit","return":"GIT_EXTERN(const char *)","function":"git_commit_message_short"},{"line":89,"comments":["/**","* Get the full message of a commit.","*","* @param commit a previously loaded commit.","* @return the message of a commit","*/"],"args":"git_commit *commit","return":"GIT_EXTERN(const char *)","function":"git_commit_message"},{"line":97,"comments":["/**","* Get the commit time (i.e. committer time) of a commit.","*","* @param commit a previously loaded commit.","* @return the time of a commit","*/"],"args":"git_commit *commit","return":"GIT_EXTERN(git_time_t)","function":"git_commit_time"},{"line":105,"comments":["/**","* Get the commit timezone offset (i.e. committer's preferred timezone) of a commit.","*","* @param commit a previously loaded commit.","* @return positive or negative timezone offset, in minutes from UTC","*/"],"args":"git_commit *commit","return":"GIT_EXTERN(int)","function":"git_commit_time_offset"},{"line":113,"comments":["/**","* Get the committer of a commit.","*","* @param commit a previously loaded commit.","* @return the committer of a commit","*/"],"args":"git_commit *commit","return":"GIT_EXTERN(const git_signature *)","function":"git_commit_committer"},{"line":121,"comments":["/**","* Get the author of a commit.","*","* @param commit a previously loaded commit.","* @return the author of a commit","*/"],"args":"git_commit *commit","return":"GIT_EXTERN(const git_signature *)","function":"git_commit_author"},{"line":129,"comments":["/**","* Get the tree pointed to by a commit.","*","* @param tree_out pointer where to store the tree object","* @param commit a previously loaded commit.","* @return 0 on success; error code otherwise","*/"],"args":"git_tree **tree_out, git_commit *commit","return":"GIT_EXTERN(int)","function":"git_commit_tree"},{"line":138,"comments":["/**","* Get the id of the tree pointed to by a commit. This differs from","* `git_commit_tree` in that no attempts are made to fetch an object","* from the ODB.","*","* @param commit a previously loaded commit.","* @return the id of tree pointed to by commit.","*/"],"args":"git_commit *commit","return":"GIT_EXTERN(const git_oid *)","function":"git_commit_tree_oid"},{"line":148,"comments":["/**","* Get the number of parents of this commit","*","* @param commit a previously loaded commit.","* @return integer of count of parents","*/"],"args":"git_commit *commit","return":"GIT_EXTERN(unsigned int)","function":"git_commit_parentcount"},{"line":156,"comments":["/**","* Get the specified parent of the commit.","*","* @param parent Pointer where to store the parent commit","* @param commit a previously loaded commit.","* @param n the position of the parent (from 0 to `parentcount`)","* @return 0 on success; error code otherwise","*/"],"args":"git_commit **parent, git_commit *commit, unsigned int n","return":"GIT_EXTERN(int)","function":"git_commit_parent"},{"line":166,"comments":["/**","* Get the oid of a specified parent for a commit. This is different from","* `git_commit_parent`, which will attempt to load the parent commit from","* the ODB.","*","* @param commit a previously loaded commit.","* @param n the position of the parent (from 0 to `parentcount`)","* @return the id of the parent, NULL on error.","*/"],"args":"git_commit *commit, unsigned int n","return":"GIT_EXTERN(const git_oid *)","function":"git_commit_parent_oid"}],"meta":{"file":"git2/commit.h","brief":"Git commit parsing, formatting routines","defgroup":"git_commit Git commit parsing, formatting routines","ingroup":"Git"}},{"file":"common.h","functions":[],"meta":{"file":"git2/common.h","brief":"Git common platform definitions","defgroup":"git_common Git common platform definitions","ingroup":"Git"}},{"file":"errors.h","functions":[{"line":128,"comments":["/**","* Return a detailed error string with the latest error","* that occurred in the library.","* @return a string explaining the error","*/"],"args":"void","return":"GIT_EXTERN(const char *)","function":"git_lasterror"},{"line":135,"comments":["/**","* strerror() for the Git library","*","* Get a string description for a given error code.","* NOTE: This method will be eventually deprecated in favor","* of the new `git_lasterror`.","*","* @param num The error code to explain","* @return a string explaining the error code","*/"],"args":"int num","return":"GIT_EXTERN(const char *)","function":"git_strerror"}],"meta":{"file":"git2/errors.h","brief":"Git error handling routines and variables","defgroup":null,"ingroup":"Git"}},{"file":"index.h","functions":[{"line":105,"comments":["/**","* Create a new Git index object as a memory representation","* of the Git index file in 'index_path', without a repository","* to back it.","*","* Since there is no ODB behind this index, any Index methods","* which rely on the ODB (e.g. index_add) will fail with the","* GIT_EBAREINDEX error code.","*","* @param index the pointer for the new index","* @param index_path the path to the index file in disk","* @return 0 on success; error code otherwise","*/"],"args":"git_index **index, const char *index_path","return":"GIT_EXTERN(int)","function":"git_index_open_bare"},{"line":120,"comments":["/**","* Open the Index inside the git repository pointed","* by 'repo'.","*","* @param index the pointer for the new index","* @param repo the git repo which owns the index","* @return 0 on success; error code otherwise","*/"],"args":"git_index **index, git_repository *repo","return":"GIT_EXTERN(int)","function":"git_index_open_inrepo"},{"line":130,"comments":["/**","* Clear the contents (all the entries) of an index object.","* This clears the index object in memory; changes must be manually","* written to disk for them to take effect.","*","* @param index an existing index object","*/"],"args":"git_index *index","return":"GIT_EXTERN(void)","function":"git_index_clear"},{"line":139,"comments":["/**","* Free an existing index object.","*","* @param index an existing index object","*/"],"args":"git_index *index","return":"GIT_EXTERN(void)","function":"git_index_free"},{"line":146,"comments":["/**","* Update the contents of an existing index object in memory","* by reading from the hard disk.","*","* @param index an existing index object","* @return 0 on success, otherwise an error code","*/"],"args":"git_index *index","return":"GIT_EXTERN(int)","function":"git_index_read"},{"line":155,"comments":["/**","* Write an existing index object from memory back to disk","* using an atomic file lock.","*","* @param index an existing index object","* @return 0 on success, otherwise an error code","*/"],"args":"git_index *index","return":"GIT_EXTERN(int)","function":"git_index_write"},{"line":164,"comments":["/**","* Find the first index of any entries which point to given","* path in the Git index.","*","* @param index an existing index object","* @param path path to search","* @return an index >= 0 if found, -1 otherwise","*/"],"args":"git_index *index, const char *path","return":"GIT_EXTERN(int)","function":"git_index_find"},{"line":174,"comments":["/**","* Add or update an index entry from a file in disk","*","* The file `path` must be relative to the repository's","* working folder and must be readable.","*","* This method will fail in bare index instances.","*","* @param index an existing index object","* @param path filename to add","* @param stage stage for the entry","* @return 0 on success, otherwise an error code","*/"],"args":"git_index *index, const char *path, int stage","return":"GIT_EXTERN(int)","function":"git_index_add"},{"line":201,"comments":["/**","* Add (append) an index entry from a file in disk","*","* A new entry will always be inserted into the index;","* if the index already contains an entry for such","* path, the old entry will **not** be replaced.","*","* The file `path` must be relative to the repository's","* working folder and must be readable.","*","* This method will fail in bare index instances.","*","* @param index an existing index object","* @param path filename to add","* @param stage stage for the entry","* @return 0 on success, otherwise an error code","*/"],"args":"git_index *index, const char *path, int stage","return":"GIT_EXTERN(int)","function":"git_index_append"},{"line":237,"comments":["/**","* Remove an entry from the index","*","* @param index an existing index object","* @param position position of the entry to remove","* @return 0 on success, otherwise an error code","*/"],"args":"git_index *index, int position","return":"GIT_EXTERN(int)","function":"git_index_remove"},{"line":247,"comments":["/**","* Get a pointer to one of the entries in the index","*","* This entry can be modified, and the changes will be written","* back to disk on the next write() call.","*","* @param index an existing index object","* @param n the position of the entry","* @return a pointer to the entry; NULL if out of bounds","*/"],"args":"git_index *index, int n","return":"GIT_EXTERN(git_index_entry *)","function":"git_index_get"},{"line":259,"comments":["/**","* Get the count of entries currently in the index","*","* @param index an existing index object","* @return integer of count of current entries","*/"],"args":"git_index *index","return":"GIT_EXTERN(unsigned int)","function":"git_index_entrycount"}],"meta":{"file":"git2/index.h","brief":"Git index parsing and manipulation routines","defgroup":"git_index Git index parsing and manipulation routines","ingroup":"Git"}},{"file":"object.h","functions":[{"line":41,"comments":["/**","* Lookup a reference to one of the objects in a repostory.","*","* The generated reference is owned by the repository and","* should be closed with the `git_object_close` method","* instead of free'd manually.","*","* The 'type' parameter must match the type of the object","* in the odb; the method will fail otherwise.","* The special value 'GIT_OBJ_ANY' may be passed to let","* the method guess the object's type.","*","* @param object pointer to the looked-up object","* @param repo the repository to look up the object","* @param id the unique identifier for the object","* @param type the type of the object","* @return a reference to the object","*/"],"args":"git_object **object, git_repository *repo, const git_oid *id, git_otype type","return":"GIT_EXTERN(int)","function":"git_object_lookup"},{"line":61,"comments":["/**","* Get the id (SHA1) of a repository object","*","* @param obj the repository object","* @return the SHA1 id","*/"],"args":"const git_object *obj","return":"GIT_EXTERN(const git_oid *)","function":"git_object_id"},{"line":69,"comments":["/**","* Get the object type of an object","*","* @param obj the repository object","* @return the object's type","*/"],"args":"const git_object *obj","return":"GIT_EXTERN(git_otype)","function":"git_object_type"},{"line":77,"comments":["/**","* Get the repository that owns this object","*","* @param obj the object","* @return the repository who owns this object","*/"],"args":"const git_object *obj","return":"GIT_EXTERN(git_repository *)","function":"git_object_owner"},{"line":85,"comments":["/**","* Close an open object","*","* This method instructs the library to close an existing","* object; note that git_objects are owned and cached by the repository","* so the object may or may not be freed after this library call,","* depending on how agressive is the caching mechanism used","* by the repository.","*","* IMPORTANT:","* It *is* necessary to call this method when you stop using","* an object. Failure to do so will cause a memory leak.","*","* @param object the object to close","*/"],"args":"git_object *object","return":"GIT_EXTERN(void)","function":"git_object_close"},{"line":121,"comments":["/**","* Determine if the given git_otype is a valid loose object type.","*","* @param type object type to test.","* @return true if the type represents a valid loose object type,","* false otherwise.","*/"],"args":"git_otype type","return":"GIT_EXTERN(int)","function":"git_object_typeisloose"},{"line":130,"comments":["/**","* Get the size in bytes for the structure which","* acts as an in-memory representation of any given","* object type.","*","* For all the core types, this would the equivalent","* of calling `sizeof(git_commit)` if the core types","* were not opaque on the external API.","*","* @param type object type to get its size","* @return size in bytes of the object","*/"],"args":"git_otype type","return":"GIT_EXTERN(size_t)","function":"git_object__size"}],"meta":{"file":"git2/object.h","brief":"Git revision object management routines","defgroup":"git_object Git revision object management routines","ingroup":"Git"}},{"file":"odb.h","functions":[{"line":42,"comments":["/**","* Create a new object database with no backends.","*","* Before the ODB can be used for read/writing, a custom database","* backend must be manually added using `git_odb_add_backend()`","*","* @param out location to store the database pointer, if opened.","*            Set to NULL if the open failed.","* @return GIT_SUCCESS if the database was created; otherwise an error","*         code describing why the open was not possible.","*/"],"args":"git_odb **out","return":"GIT_EXTERN(int)","function":"git_odb_new"},{"line":55,"comments":["/**","* Create a new object database and automatically add","* the two default backends:","*","*\t- git_odb_backend_loose: read and write loose object files","*\t\tfrom disk, assuming `objects_dir` as the Objects folder","*","*\t- git_odb_backend_pack: read objects from packfiles,","*\t\tassuming `objects_dir` as the Objects folder which","*\t\tcontains a 'pack/' folder with the corresponding data","*","* @param out location to store the database pointer, if opened.","*            Set to NULL if the open failed.","* @param objects_dir path of the backends' \"objects\" directory.","* @return GIT_SUCCESS if the database opened; otherwise an error","*         code describing why the open was not possible.","*/"],"args":"git_odb **out, const char *objects_dir","return":"GIT_EXTERN(int)","function":"git_odb_open"},{"line":74,"comments":["/**","* Add a custom backend to an existing Object DB","*","* Read <odb_backends.h> for more information.","*","* @param odb database to add the backend to","* @paramm backend pointer to a git_odb_backend instance","* @return 0 on sucess; error code otherwise","*/"],"args":"git_odb *odb, git_odb_backend *backend, int priority","return":"GIT_EXTERN(int)","function":"git_odb_add_backend"},{"line":85,"comments":["/**","* Add a custom backend to an existing Object DB; this","* backend will work as an alternate.","*","* Alternate backends are always checked for objects *after*","* all the main backends have been exhausted.","*","* Writing is disabled on alternate backends.","*","* Read <odb_backends.h> for more information.","*","* @param odb database to add the backend to","* @paramm backend pointer to a git_odb_backend instance","* @return 0 on sucess; error code otherwise","*/"],"args":"git_odb *odb, git_odb_backend *backend, int priority","return":"GIT_EXTERN(int)","function":"git_odb_add_alternate"},{"line":102,"comments":["/**","* Close an open object database.","*","* @param db database pointer to close.  If NULL no action is taken.","*/"],"args":"git_odb *db","return":"GIT_EXTERN(void)","function":"git_odb_close"},{"line":109,"comments":["/**","* Read an object from the database.","*","* This method queries all avaiable ODB backends","* trying to read the given OID.","*","* The returned object is reference counted and","* internally cached, so it should be closed","* by the user once it's no longer in use.","*","* @param out pointer where to store the read object","* @param db database to search for the object in.","* @param id identity of the object to read.","* @return","* - GIT_SUCCESS if the object was read;","* - GIT_ENOTFOUND if the object is not in the database.","*/"],"args":"git_odb_object **out, git_odb *db, const git_oid *id","return":"GIT_EXTERN(int)","function":"git_odb_read"},{"line":128,"comments":["/**","* Read the header of an object from the database, without","* reading its full contents.","*","* The header includes the length and the type of an object.","*","* Note that most backends do not support reading only the header","* of an object, so the whole object will be read and then the","* header will be returned.","*","* @param len_p pointer where to store the length","* @param type_p pointer where to store the type","* @param db database to search for the object in.","* @param id identity of the object to read.","* @return","* - GIT_SUCCESS if the object was read;","* - GIT_ENOTFOUND if the object is not in the database.","*/"],"args":"size_t *len_p, git_otype *type_p, git_odb *db, const git_oid *id","return":"GIT_EXTERN(int)","function":"git_odb_read_header"},{"line":148,"comments":["/**","* Determine if the given object can be found in the object database.","*","* @param db database to be searched for the given object.","* @param id the object to search for.","* @return","* - 1, if the object was found","* - 0, otherwise","*/"],"args":"git_odb *db, const git_oid *id","return":"GIT_EXTERN(int)","function":"git_odb_exists"},{"line":159,"comments":["/**","* Write an object directly into the ODB","*","* This method writes a full object straight into the ODB.","* For most cases, it is preferred to write objects through a write","* stream, which is both faster and less memory intensive, specially","* for big objects.","*","* This method is provided for compatibility with custom backends","* which are not able to support streaming writes","*","* @param oid pointer to store the OID result of the write","* @param odb object database where to store the object","* @param data buffer with the data to storr","* @param len size of the buffer","* @param type type of the data to store","* @return 0 on success; error code otherwise","*/"],"args":"git_oid *oid, git_odb *odb, const void *data, size_t len, git_otype type","return":"GIT_EXTERN(int)","function":"git_odb_write"},{"line":179,"comments":["/**","* Open a stream to write an object into the ODB","*","* The type and final length of the object must be specified","* when opening the stream.","*","* The returned stream will be of type `GIT_STREAM_WRONLY` and","* will have the following methods:","*","*\t\t- stream->write: write `n` bytes into the stream","*\t\t- stream->finalize_write: close the stream and store the object in","*\t\t\tthe odb","*\t\t- stream->free: free the stream","*","* The streaming write won't be effective until `stream->finalize_write`","* is called and returns without an error","*","* The stream must always be free'd or will leak memory.","*","* @see git_odb_stream","*","* @param stream pointer where to store the stream","* @param db object database where the stream will write","* @param size final size of the object that will be written","* @param type type of the object that will be written","* @return 0 if the stream was created; error code otherwise","*/"],"args":"git_odb_stream **stream, git_odb *db, size_t size, git_otype type","return":"GIT_EXTERN(int)","function":"git_odb_open_wstream"},{"line":208,"comments":["/**","* Open a stream to read an object from the ODB","*","* Note that most backends do *not* support streaming reads","* because they store their objects as compressed/delta'ed blobs.","*","* It's recommended to use `git_odb_read` instead, which is","* assured to work on all backends.","*","* The returned stream will be of type `GIT_STREAM_RDONLY` and","* will have the following methods:","*","*\t\t- stream->read: read `n` bytes from the stream","*\t\t- stream->free: free the stream","*","* The stream must always be free'd or will leak memory.","*","* @see git_odb_stream","*","* @param stream pointer where to store the stream","* @param db object database where the stream will read from","* @param oid oid of the object the stream will read from","* @return 0 if the stream was created; error code otherwise","*/"],"args":"git_odb_stream **stream, git_odb *db, const git_oid *oid","return":"GIT_EXTERN(int)","function":"git_odb_open_rstream"},{"line":234,"comments":["/**","* Determine the object-ID (sha1 hash) of a data buffer","*","* The resulting SHA-1 OID will the itentifier for the data","* buffer as if the data buffer it were to written to the ODB.","*","* @param id the resulting object-ID.","* @param data data to hash","* @param len size of the data","* @param type of the data to hash","* @return 0 on success; error code otherwise","*/"],"args":"git_oid *id, const void *data, size_t len, git_otype type","return":"GIT_EXTERN(int)","function":"git_odb_hash"},{"line":248,"comments":["/**","* Close an ODB object","*","* This method must always be called once a `git_odb_object` is no","* longer needed, otherwise memory will leak.","*","* @param object object to close","*/"],"args":"git_odb_object *object","return":"GIT_EXTERN(void)","function":"git_odb_object_close"},{"line":258,"comments":["/**","* Return the OID of an ODB object","*","* This is the OID from which the object was read from","*","* @param object the object","* @return a pointer to the OID","*/"],"args":"git_odb_object *object","return":"GIT_EXTERN(const git_oid *)","function":"git_odb_object_id"},{"line":268,"comments":["/**","* Return the data of an ODB object","*","* This is the uncompressed, raw data as read from the ODB,","* without the leading header.","*","* This pointer is owned by the object and shall not be free'd.","*","* @param object the object","* @return a pointer to the data","*/"],"args":"git_odb_object *object","return":"GIT_EXTERN(const void *)","function":"git_odb_object_data"},{"line":281,"comments":["/**","* Return the size of an ODB object","*","* This is the real size of the `data` buffer, not the","* actual size of the object.","*","* @param object the object","* @return the size","*/"],"args":"git_odb_object *object","return":"GIT_EXTERN(size_t)","function":"git_odb_object_size"},{"line":292,"comments":["/**","* Return the type of an ODB object","*","* @param object the object","* @return the type","*/"],"args":"git_odb_object *object","return":"GIT_EXTERN(git_otype)","function":"git_odb_object_type"}],"meta":{"file":"git2/odb.h","brief":"Git object database routines","defgroup":"git_odb Git object database routines","ingroup":"Git"}},{"file":"odb_backend.h","functions":[],"meta":{"file":"git2/backend.h","brief":"Git custom backend functions","defgroup":"git_backend Git custom backend API","ingroup":"Git"}},{"file":"oid.h","functions":[{"line":52,"comments":["/**","* Parse a hex formatted object id into a git_oid.","* @param out oid structure the result is written into.","* @param str input hex string; must be pointing at the start of","*        the hex sequence and have at least the number of bytes","*        needed for an oid encoded in hex (40 bytes).","* @return GIT_SUCCESS if valid; GIT_ENOTOID on failure.","*/"],"args":"git_oid *out, const char *str","return":"GIT_EXTERN(int)","function":"git_oid_mkstr"},{"line":62,"comments":["/**","* Copy an already raw oid into a git_oid structure.","* @param out oid structure the result is written into.","* @param raw the raw input bytes to be copied.","*/"],"args":"git_oid *out, const unsigned char *raw","return":"GIT_EXTERN(void)","function":"git_oid_mkraw"},{"line":69,"comments":["/**","* Format a git_oid into a hex string.","* @param str output hex string; must be pointing at the start of","*        the hex sequence and have at least the number of bytes","*        needed for an oid encoded in hex (40 bytes).  Only the","*        oid digits are written; a '\\\\0' terminator must be added","*        by the caller if it is required.","* @param oid oid structure to format.","*/"],"args":"char *str, const git_oid *oid","return":"GIT_EXTERN(void)","function":"git_oid_fmt"},{"line":80,"comments":["/**","* Format a git_oid into a loose-object path string.","* <p>","* The resulting string is \"aa/...\", where \"aa\" is the first two","* hex digitis of the oid and \"...\" is the remaining 38 digits.","*","* @param str output hex string; must be pointing at the start of","*        the hex sequence and have at least the number of bytes","*        needed for an oid encoded in hex (41 bytes).  Only the","*        oid digits are written; a '\\\\0' terminator must be added","*        by the caller if it is required.","* @param oid oid structure to format.","*/"],"args":"char *str, const git_oid *oid","return":"GIT_EXTERN(void)","function":"git_oid_pathfmt"},{"line":95,"comments":["/**","* Format a gid_oid into a newly allocated c-string.","* @param oid the oid structure to format","* @return the c-string; NULL if memory is exhausted.  Caller must","*         deallocate the string with free().","*/"],"args":"const git_oid *oid","return":"GIT_EXTERN(char *)","function":"git_oid_allocfmt"},{"line":103,"comments":["/**","* Format a git_oid into a buffer as a hex format c-string.","* <p>","* If the buffer is smaller than GIT_OID_HEXSZ+1, then the resulting","* oid c-string will be truncated to n-1 characters. If there are","* any input parameter errors (out == NULL, n == 0, oid == NULL),","* then a pointer to an empty string is returned, so that the return","* value can always be printed.","*","* @param out the buffer into which the oid string is output.","* @param n the size of the out buffer.","* @param oid the oid structure to format.","* @return the out buffer pointer, assuming no input parameter","*         errors, otherwise a pointer to an empty string.","*/"],"args":"char *out, size_t n, const git_oid *oid","return":"GIT_EXTERN(char *)","function":"git_oid_to_string"},{"line":120,"comments":["/**","* Copy an oid from one structure to another.","* @param out oid structure the result is written into.","* @param src oid structure to copy from.","*/"],"args":"git_oid *out, const git_oid *src","return":"GIT_EXTERN(void)","function":"git_oid_cpy"},{"line":127,"comments":["/**","* Compare two oid structures.","* @param a first oid structure.","* @param b second oid structure.","* @return <0, 0, >0 if a < b, a == b, a > b.","*/"],"args":"const git_oid *a, const git_oid *b","return":"GIT_EXTERN(int)","function":"git_oid_cmp"},{"line":156,"comments":["/**","* Add a new OID to set of shortened OIDs and calculate","* the minimal length to uniquely identify all the OIDs in","* the set.","*","* The OID is expected to be a 40-char hexadecimal string.","* The OID is owned by the user and will not be modified","* or freed.","*","* For performance reasons, there is a hard-limit of how many","* OIDs can be added to a single set (around ~22000, assuming","* a mostly randomized distribution), which should be enough","* for any kind of program, and keeps the algorithm fast and","* memory-efficient.","*","* Attempting to add more than those OIDs will result in a","* GIT_ENOMEM error","*","* @param os a `git_oid_shorten` instance","* @param text_oid an OID in text form","* @return the minimal length to uniquely identify all OIDs","*\t\tadded so far to the set; or an error code (<0) if an","*\t\terror occurs.","*/"],"args":"git_oid_shorten *os, const char *text_oid","return":"int","function":"git_oid_shorten_add"},{"line":182,"comments":["/**","* Free an OID shortener instance","*","* @param os a `git_oid_shorten` instance","*/"],"args":"git_oid_shorten *os","return":"void","function":"git_oid_shorten_free"}],"meta":{"file":"git2/oid.h","brief":"Git object id routines","defgroup":"git_oid Git object id routines","ingroup":"Git"}},{"file":"refs.h","functions":[{"line":41,"comments":["/**","* Lookup a reference by its name in a repository.","*","* The generated reference is owned by the repository and","* should not be freed by the user.","*","* @param reference_out pointer to the looked-up reference","* @param repo the repository to look up the reference","* @param name the long name for the reference (e.g. HEAD, ref/heads/master, refs/tags/v0.1.0, ...)","* @return 0 on success; error code otherwise","*/"],"args":"git_reference **reference_out, git_repository *repo, const char *name","return":"GIT_EXTERN(int)","function":"git_reference_lookup"},{"line":54,"comments":["/**","* Create a new symbolic reference.","*","* The reference will be created in the repository and written","* to the disk.","*","* This reference is owned by the repository and shall not","* be free'd by the user.","*","* @param ref_out Pointer to the newly created reference","* @param repo Repository where that reference will live","* @param name The name of the reference","* @param target The target of the reference","* @return 0 on success; error code otherwise","*/"],"args":"git_reference **ref_out, git_repository *repo, const char *name, const char *target","return":"GIT_EXTERN(int)","function":"git_reference_create_symbolic"},{"line":71,"comments":["/**","* Create a new symbolic reference, overwriting an existing one with","* the same name, if it exists.","*","* If the new reference isn't a symbolic one, any pointers to the old","* reference become invalid.","*","* The reference will be created in the repository and written","* to the disk.","*","* This reference is owned by the repository and shall not","* be free'd by the user.","*","* @param ref_out Pointer to the newly created reference","* @param repo Repository where that reference will live","* @param name The name of the reference","* @param target The target of the reference","* @return 0 on success; error code otherwise","*/"],"args":"git_reference **ref_out, git_repository *repo, const char *name, const char *target","return":"GIT_EXTERN(int)","function":"git_reference_create_symbolic_f"},{"line":92,"comments":["/**","* Create a new object id reference.","*","* The reference will be created in the repository and written","* to the disk.","*","* This reference is owned by the repository and shall not","* be free'd by the user.","*","* @param ref_out Pointer to the newly created reference","* @param repo Repository where that reference will live","* @param name The name of the reference","* @param id The object id pointed to by the reference.","* @return 0 on success; error code otherwise","*/"],"args":"git_reference **ref_out, git_repository *repo, const char *name, const git_oid *id","return":"GIT_EXTERN(int)","function":"git_reference_create_oid"},{"line":109,"comments":["/**","* Create a new object id reference, overwriting an existing one with","* the same name, if it exists.","*","* If the new reference isn't an object id one, any pointers to the","* old reference become invalid.","*","* The reference will be created in the repository and written","* to the disk.","*","* This reference is owned by the repository and shall not","* be free'd by the user.","*","* @param ref_out Pointer to the newly created reference","* @param repo Repository where that reference will live","* @param name The name of the reference","* @param id The object id pointed to by the reference.","* @return 0 on success; error code otherwise","*/"],"args":"git_reference **ref_out, git_repository *repo, const char *name, const git_oid *id","return":"GIT_EXTERN(int)","function":"git_reference_create_oid_f"},{"line":130,"comments":["/**","* Get the OID pointed to by a reference.","*","* Only available if the reference is direct (i.e. not symbolic)","*","* @param ref The reference","* @return a pointer to the oid if available, NULL otherwise","*/"],"args":"git_reference *ref","return":"GIT_EXTERN(const git_oid *)","function":"git_reference_oid"},{"line":140,"comments":["/**","* Get full name to the reference pointed by this reference","*","* Only available if the reference is symbolic","*","* @param ref The reference","* @return a pointer to the name if available, NULL otherwise","*/"],"args":"git_reference *ref","return":"GIT_EXTERN(const char *)","function":"git_reference_target"},{"line":150,"comments":["/**","* Get the type of a reference","*","* Either direct (GIT_REF_OID) or symbolic (GIT_REF_SYMBOLIC)","*","* @param ref The reference","* @return the type","*/"],"args":"git_reference *ref","return":"GIT_EXTERN(git_rtype)","function":"git_reference_type"},{"line":160,"comments":["/**","* Get the full name of a reference","*","* @param ref The reference","* @return the full name for the ref","*/"],"args":"git_reference *ref","return":"GIT_EXTERN(const char *)","function":"git_reference_name"},{"line":168,"comments":["/**","* Resolve a symbolic reference","*","* Thie method iteratively peels a symbolic reference","* until it resolves to a direct reference to an OID.","*","* If a direct reference is passed as an argument,","* that reference is returned immediately","*","* @param resolved_ref Pointer to the peeled reference","* @param ref The reference","* @return 0 on success; error code otherwise","*/"],"args":"git_reference **resolved_ref, git_reference *ref","return":"GIT_EXTERN(int)","function":"git_reference_resolve"},{"line":183,"comments":["/**","* Get the repository where a reference resides","*","* @param ref The reference","* @return a pointer to the repo","*/"],"args":"git_reference *ref","return":"GIT_EXTERN(git_repository *)","function":"git_reference_owner"},{"line":191,"comments":["/**","* Set the symbolic target of a reference.","*","* The reference must be a symbolic reference, otherwise","* this method will fail.","*","* The reference will be automatically updated in","* memory and on disk.","*","* @param ref The reference","* @param target The new target for the reference","* @return 0 on success; error code otherwise","*/"],"args":"git_reference *ref, const char *target","return":"GIT_EXTERN(int)","function":"git_reference_set_target"},{"line":206,"comments":["/**","* Set the OID target of a reference.","*","* The reference must be a direct reference, otherwise","* this method will fail.","*","* The reference will be automatically updated in","* memory and on disk.","*","* @param ref The reference","* @param target The new target OID for the reference","* @return 0 on success; error code otherwise","*/"],"args":"git_reference *ref, const git_oid *id","return":"GIT_EXTERN(int)","function":"git_reference_set_oid"},{"line":221,"comments":["/**","* Rename an existing reference","*","* This method works for both direct and symbolic references.","* The new name will be checked for validity and may be","* modified into a normalized form.","*","* The refernece will be immediately renamed in-memory","* and on disk.","*","*/"],"args":"git_reference *ref, const char *new_name","return":"GIT_EXTERN(int)","function":"git_reference_rename"},{"line":234,"comments":["/**","* Rename an existing reference, overwriting an existing one with the","* same name, if it exists.","*","* This method works for both direct and symbolic references.","* The new name will be checked for validity and may be","* modified into a normalized form.","*","* The refernece will be immediately renamed in-memory","* and on disk.","*","*/"],"args":"git_reference *ref, const char *new_name","return":"GIT_EXTERN(int)","function":"git_reference_rename_f"},{"line":248,"comments":["/**","* Delete an existing reference","*","* This method works for both direct and symbolic references.","*","* The reference will be immediately removed on disk and from","* memory. The given reference pointer will no longer be valid.","*","*/"],"args":"git_reference *ref","return":"GIT_EXTERN(int)","function":"git_reference_delete"},{"line":259,"comments":["/**","* Pack all the loose references in the repository","*","* This method will load into the cache all the loose","* references on the repository and update the","* `packed-refs` file with them.","*","* Once the `packed-refs` file has been written properly,","* the loose references will be removed from disk.","*","* WARNING: calling this method may invalidate any existing","* references previously loaded on the cache.","*","* @param repo Repository where the loose refs will be packed","* @return 0 on success; error code otherwise","*/"],"args":"git_repository *repo","return":"GIT_EXTERN(int)","function":"git_reference_packall"},{"line":277,"comments":["/**","* Fill a list with all the references that can be found","* in a repository.","*","* The listed references may be filtered by type, or using","* a bitwise OR of several types. Use the magic value","* `GIT_REF_LISTALL` to obtain all references, including","* packed ones.","*","* The string array will be filled with the names of all","* references; these values are owned by the user and","* should be free'd manually when no longer needed, using","* `git_strarray_free`.","*","* @param array Pointer to a git_strarray structure where","*\t\tthe reference names will be stored","* @param repo Repository where to find the refs","* @param list_flags Filtering flags for the reference","*\t\tlisting.","* @return 0 on success; error code otherwise","*/"],"args":"git_strarray *array, git_repository *repo, unsigned int list_flags","return":"GIT_EXTERN(int)","function":"git_reference_listall"},{"line":301,"comments":["/**","* List all the references in the repository, calling a custom","* callback for each one.","*","* The listed references may be filtered by type, or using","* a bitwise OR of several types. Use the magic value","* `GIT_REF_LISTALL` to obtain all references, including","* packed ones.","*","* The `callback` function will be called for each of the references","* in the repository, and will receive the name of the reference and","* the `payload` value passed to this method.","*","* @param repo Repository where to find the refs","* @param list_flags Filtering flags for the reference","*\t\tlisting.","* @param callback Function which will be called for every listed ref","* @param payload Additional data to pass to the callback","* @return 0 on success; error code otherwise","*/"],"args":"git_repository *repo, unsigned int list_flags, int (*callback)(const char *, void *), void *payload","return":"GIT_EXTERN(int)","function":"git_reference_listcb"}],"meta":{"file":"git2/refs.h","brief":"Git reference management routines","defgroup":"git_reference Git reference management routines","ingroup":"Git"}},{"file":"repository.h","functions":[{"line":41,"comments":["/**","* Open a git repository.","*","* The 'path' argument must point to an existing git repository","* folder, e.g.","*","*\t\t/path/to/my_repo/.git/\t(normal repository)","*\t\t\t\t\t\t\tobjects/","*\t\t\t\t\t\t\tindex","*\t\t\t\t\t\t\tHEAD","*","*\t\t/path/to/bare_repo/\t\t(bare repository)","*\t\t\t\t\t\tobjects/","*\t\t\t\t\t\tindex","*\t\t\t\t\t\tHEAD","*","*\tThe method will automatically detect if 'path' is a normal","*\tor bare repository or fail is 'path' is neither.","*","* @param repository pointer to the repo which will be opened","* @param path the path to the repository","* @return 0 on success; error code otherwise","*/"],"args":"git_repository **repository, const char *path","return":"GIT_EXTERN(int)","function":"git_repository_open"},{"line":135,"comments":["/**","* Get the object database behind a Git repository","*","* @param repo a repository object","* @return a pointer to the object db","*/"],"args":"git_repository *repo","return":"GIT_EXTERN(git_odb *)","function":"git_repository_database"},{"line":143,"comments":["/**","* Get the Index file of a Git repository","*","* This is a cheap operation; the index is only opened on the first call,","* and subsequent calls only retrieve the previous pointer.","*","* @param index Pointer where to store the index","* @param repo a repository object","* @return 0 on success; error code if the index could not be opened","*/"],"args":"git_index **index, git_repository *repo","return":"GIT_EXTERN(int)","function":"git_repository_index"},{"line":155,"comments":["/**","* Free a previously allocated repository","*","* Note that after a repository is free'd, all the objects it has spawned","* will still exist until they are manually closed by the user","* with `git_object_close`, but accessing any of the attributes of","* an object without a backing repository will result in undefined","* behavior","*","* @param repo repository handle to close. If NULL nothing occurs.","*/"],"args":"git_repository *repo","return":"GIT_EXTERN(void)","function":"git_repository_free"},{"line":168,"comments":["/**","* Creates a new Git repository in the given folder.","*","* TODO:","*\t- Reinit the repository","*\t- Create config files","*","* @param repo_out pointer to the repo which will be created or reinitialized","* @param path the path to the repository","* @param is_bare if true, a Git repository without a working directory is created","*\t\tat the pointed path. If false, provided path will be considered as the working","*\t\tdirectory into which the .git directory will be created.","*","* @return 0 on success; error code otherwise","*/"],"args":"git_repository **repo_out, const char *path, unsigned is_bare","return":"GIT_EXTERN(int)","function":"git_repository_init"},{"line":185,"comments":["/**","* Check if a repository is empty","*","* An empty repository has just been initialized and contains","* no commits.","*","* @param repo Repo to test","* @return 1 if the repository is empty, 0 if it isn't, error code","* if the repository is corrupted","*/"],"args":"git_repository *repo","return":"GIT_EXTERN(int)","function":"git_repository_is_empty"},{"line":197,"comments":["/**","* Get the normalized path to the git repository.","*","* @param repo a repository object","* @return absolute path to the git directory","*/"],"args":"git_repository *repo","return":"GIT_EXTERN(const char *)","function":"git_repository_path"},{"line":205,"comments":["/**","* Get the normalized path to the working directory of the repository.","*","* If the repository is bare, there is no working directory and NULL we be returned.","*","* @param repo a repository object","* @return NULL if the repository is bare; absolute path to the working directory otherwise.","*/"],"args":"git_repository *repo","return":"GIT_EXTERN(const char *)","function":"git_repository_workdir"}],"meta":{"file":"git2/repository.h","brief":"Git repository management routines","defgroup":"git_repository Git repository management routines","ingroup":"Git"}},{"file":"revwalk.h","functions":[{"line":70,"comments":["/**","* Allocate a new revision walker to iterate through a repo.","*","* This revision walker uses a custom memory pool and an internal","* commit cache, so it is relatively expensive to allocate.","*","* For maximum performance, this revision walker should be","* reused for different walks.","*","* This revision walker is *not* thread safe: it may only be","* used to walk a repository on a single thread; however,","* it is possible to have several revision walkers in","* several different threads walking the same repository.","*","* @param walker pointer to the new revision walker","* @param repo the repo to walk through","* @return 0 on success; error code otherwise","*/"],"args":"git_revwalk **walker, git_repository *repo","return":"GIT_EXTERN(int)","function":"git_revwalk_new"},{"line":90,"comments":["/**","* Reset the revision walker for reuse.","*","* This will clear all the pushed and hidden commits, and","* leave the walker in a blank state (just like at","* creation) ready to receive new commit pushes and","* start a new walk.","*","* The revision walk is automatically reset when a walk","* is over.","*","* @param walker handle to reset.","*/"],"args":"git_revwalk *walker","return":"GIT_EXTERN(void)","function":"git_revwalk_reset"},{"line":105,"comments":["/**","* Mark a commit to start traversal from.","*","* The given OID must belong to a commit on the walked","* repository.","*","* The given commit will be used as one of the roots","* when starting the revision walk. At least one commit","* must be pushed the repository before a walk can","* be started.","*","* @param walker the walker being used for the traversal.","* @param oid the oid of the commit to start from.","* @return 0 on success; error code otherwise","*/"],"args":"git_revwalk *walk, const git_oid *oid","return":"GIT_EXTERN(int)","function":"git_revwalk_push"},{"line":123,"comments":["/**","* Mark a commit (and its ancestors) uninteresting for the output.","*","* The given OID must belong to a commit on the walked","* repository.","*","* The resolved commit and all its parents will be hidden from the","* output on the revision walk.","*","* @param walker the walker being used for the traversal.","* @param commit the commit that will be ignored during the traversal","* @return 0 on success; error code otherwise","*/"],"args":"git_revwalk *walk, const git_oid *oid","return":"GIT_EXTERN(int)","function":"git_revwalk_hide"},{"line":138,"comments":["/**","* Get the next commit from the revision walk.","*","* The initial call to this method is *not* blocking when","* iterating through a repo with a time-sorting mode.","*","* Iterating with Topological or inverted modes makes the initial","* call blocking to preprocess the commit list, but this block should be","* mostly unnoticeable on most repositories (topological preprocessing","* times at 0.3s on the git.git repo).","*","* The revision walker is reset when the walk is over.","*","* @param oid Pointer where to store the oid of the next commit","* @param walk the walker to pop the commit from.","* @return GIT_SUCCESS if the next commit was found;","*\tGIT_EREVWALKOVER if there are no commits left to iterate","*/"],"args":"git_oid *oid, git_revwalk *walk","return":"GIT_EXTERN(int)","function":"git_revwalk_next"},{"line":158,"comments":["/**","* Change the sorting mode when iterating through the","* repository's contents.","*","* Changing the sorting mode resets the walker.","*","* @param walk the walker being used for the traversal.","* @param sort_mode combination of GIT_SORT_XXX flags","*/"],"args":"git_revwalk *walk, unsigned int sort_mode","return":"GIT_EXTERN(void)","function":"git_revwalk_sorting"},{"line":169,"comments":["/**","* Free a revision walker previously allocated.","*","* @param walk traversal handle to close.  If NULL nothing occurs.","*/"],"args":"git_revwalk *walk","return":"GIT_EXTERN(void)","function":"git_revwalk_free"},{"line":176,"comments":["/**","* Return the repository on which this walker","* is operating.","*","* @param walk the revision walker","* @return the repository being walked","*/"],"args":"git_revwalk *walk","return":"GIT_EXTERN(git_repository *)","function":"git_revwalk_repository"}],"meta":{"file":"git2/revwalk.h","brief":"Git revision traversal routines","defgroup":"git_revwalk Git revision traversal routines","ingroup":"Git"}},{"file":"signature.h","functions":[{"line":40,"comments":["/**","* Create a new action signature. The signature must be freed","* manually or using git_signature_free","*","* @param name name of the person","* @param mail email of the person","* @param time time when the action happened","* @param offset timezone offset in minutes for the time","* @return the new sig, NULL on out of memory","*/"],"args":"const char *name, const char *email, git_time_t time, int offset","return":"GIT_EXTERN(git_signature *)","function":"git_signature_new"},{"line":52,"comments":["/**","* Create a new action signature with a timestamp of 'now'. The","* signature must be freed manually or using git_signature_free","*","* @param name name of the person","* @param email email of the person","* @return the new sig, NULL on out of memory","*/"],"args":"const char *name, const char *email","return":"GIT_EXTERN(git_signature *)","function":"git_signature_now"},{"line":63,"comments":["/**","* Create a copy of an existing signature.","*","* All internal strings are also duplicated.","* @param sig signature to duplicated","* @return a copy of sig, NULL on out of memory","*/"],"args":"const git_signature *sig","return":"GIT_EXTERN(git_signature *)","function":"git_signature_dup"},{"line":72,"comments":["/**","* Free an existing signature","*","* @param sig signature to free","*/"],"args":"git_signature *sig","return":"GIT_EXTERN(void)","function":"git_signature_free"}],"meta":{"file":"git2/signature.h","brief":"Git signature creation","defgroup":"git_signature Git signature creation","ingroup":"Git"}},{"file":"tag.h","functions":[{"line":42,"comments":["/**","* Lookup a tag object from the repository.","*","* @param tag pointer to the looked up tag","* @param repo the repo to use when locating the tag.","* @param id identity of the tag to locate.","* @return 0 on success; error code otherwise","*/"],"args":"git_tag **tag, git_repository *repo, const git_oid *id","return":"GIT_INLINE(int)","function":"git_tag_lookup"},{"line":55,"comments":["/**","* Close an open tag","*","* This is a wrapper around git_object_close()","*","* IMPORTANT:","* It *is* necessary to call this method when you stop","* using a tag. Failure to do so will cause a memory leak.","*","* @param tag the tag to close","*/"],"args":"git_tag *tag","return":"GIT_INLINE(void)","function":"git_tag_close"},{"line":73,"comments":["/**","* Get the id of a tag.","*","* @param tag a previously loaded tag.","* @return object identity for the tag.","*/"],"args":"git_tag *tag","return":"GIT_EXTERN(const git_oid *)","function":"git_tag_id"},{"line":81,"comments":["/**","* Get the tagged object of a tag","*","* This method performs a repository lookup for the","* given object and returns it","*","* @param target pointer where to store the target","* @param tag a previously loaded tag.","* @return 0 on success; error code otherwise","*/"],"args":"git_object **target, git_tag *t","return":"GIT_EXTERN(int)","function":"git_tag_target"},{"line":93,"comments":["/**","* Get the OID of the tagged object of a tag","*","* @param tag a previously loaded tag.","* @return pointer to the OID","*/"],"args":"git_tag *t","return":"GIT_EXTERN(const git_oid *)","function":"git_tag_target_oid"},{"line":101,"comments":["/**","* Get the type of a tag's tagged object","*","* @param tag a previously loaded tag.","* @return type of the tagged object","*/"],"args":"git_tag *t","return":"GIT_EXTERN(git_otype)","function":"git_tag_type"},{"line":109,"comments":["/**","* Get the name of a tag","*","* @param tag a previously loaded tag.","* @return name of the tag","*/"],"args":"git_tag *t","return":"GIT_EXTERN(const char *)","function":"git_tag_name"},{"line":117,"comments":["/**","* Get the tagger (author) of a tag","*","* @param tag a previously loaded tag.","* @return reference to the tag's author","*/"],"args":"git_tag *t","return":"GIT_EXTERN(const git_signature *)","function":"git_tag_tagger"},{"line":125,"comments":["/**","* Get the message of a tag","*","* @param tag a previously loaded tag.","* @return message of the tag","*/"],"args":"git_tag *t","return":"GIT_EXTERN(const char *)","function":"git_tag_message"}],"meta":{"file":"git2/tag.h","brief":"Git tag parsing routines","defgroup":"git_tag Git tag management","ingroup":"Git"}},{"file":"thread-utils.h","functions":[],"meta":{"file":null,"brief":null,"defgroup":null,"ingroup":null}},{"file":"tree.h","functions":[{"line":42,"comments":["/**","* Lookup a tree object from the repository.","*","* @param tree pointer to the looked up tree","* @param repo the repo to use when locating the tree.","* @param id identity of the tree to locate.","* @return 0 on success; error code otherwise","*/"],"args":"git_tree **tree, git_repository *repo, const git_oid *id","return":"GIT_INLINE(int)","function":"git_tree_lookup"},{"line":55,"comments":["/**","* Close an open tree","*","* This is a wrapper around git_object_close()","*","* IMPORTANT:","* It *is* necessary to call this method when you stop","* using a tree. Failure to do so will cause a memory leak.","*","* @param tree the tree to close","*/"],"args":"git_tree *tree","return":"GIT_INLINE(void)","function":"git_tree_close"},{"line":73,"comments":["/**","* Get the id of a tree.","*","* @param tree a previously loaded tree.","* @return object identity for the tree.","*/"],"args":"git_tree *tree","return":"GIT_EXTERN(const git_oid *)","function":"git_tree_id"},{"line":81,"comments":["/**","* Get the number of entries listed in a tree","*","* @param tree a previously loaded tree.","* @return the number of entries in the tree","*/"],"args":"git_tree *tree","return":"GIT_EXTERN(size_t)","function":"git_tree_entrycount"},{"line":89,"comments":["/**","* Lookup a tree entry by its filename","*","* @param tree a previously loaded tree.","* @param filename the filename of the desired entry","* @return the tree entry; NULL if not found","*/"],"args":"git_tree *tree, const char *filename","return":"GIT_EXTERN(const git_tree_entry *)","function":"git_tree_entry_byname"},{"line":98,"comments":["/**","* Lookup a tree entry by its position in the tree","*","* @param tree a previously loaded tree.","* @param idx the position in the entry list","* @return the tree entry; NULL if not found","*/"],"args":"git_tree *tree, int idx","return":"GIT_EXTERN(const git_tree_entry *)","function":"git_tree_entry_byindex"},{"line":107,"comments":["/**","* Get the UNIX file attributes of a tree entry","*","* @param entry a tree entry","* @return attributes as an integer","*/"],"args":"const git_tree_entry *entry","return":"GIT_EXTERN(unsigned int)","function":"git_tree_entry_attributes"},{"line":115,"comments":["/**","* Get the filename of a tree entry","*","* @param entry a tree entry","* @return the name of the file","*/"],"args":"const git_tree_entry *entry","return":"GIT_EXTERN(const char *)","function":"git_tree_entry_name"},{"line":123,"comments":["/**","* Get the id of the object pointed by the entry","*","* @param entry a tree entry","* @return the oid of the object","*/"],"args":"const git_tree_entry *entry","return":"GIT_EXTERN(const git_oid *)","function":"git_tree_entry_id"},{"line":141,"comments":["/**","* Write a tree to the ODB from the index file","*","* This method will scan the index and write a representation","* of its current state back to disk; it recursively creates","* tree objects for each of the subtrees stored in the index,","* but only returns the OID of the root tree. This is the OID","* that can be used e.g. to create a commit.","*","* The index instance cannot be bare, and needs to be associated","* to an existing repository.","*","* @param oid Pointer where to store the written tree","* @param index Index to write","* @return 0 on success; error code otherwise","*/"],"args":"git_oid *oid, git_index *index","return":"GIT_EXTERN(int)","function":"git_tree_create_fromindex"},{"line":159,"comments":["/**","* Create a new tree builder.","*","* The tree builder can be used to create or modify","* trees in memory and write them as tree objects to the","* database.","*","* If the `source` parameter is not NULL, the tree builder","* will be initialized with the entries of the given tree.","*","* If the `source` parameter is NULL, the tree builder will","* have no entries and will have to be filled manually.","*","* @param builder_p Pointer where to store the tree builder","* @param source Source tree to initialize the builder (optional)","* @return 0 on sucess; error code otherwise","*/"],"args":"git_treebuilder **builder_p, const git_tree *source","return":"GIT_EXTERN(int)","function":"git_treebuilder_create"},{"line":178,"comments":["/**","* Clear all the entires in the builder","*","* @param bld Builder to clear","*/"],"args":"git_treebuilder *bld","return":"GIT_EXTERN(void)","function":"git_treebuilder_clear"},{"line":185,"comments":["/**","* Free a tree builder","*","* This will clear all the entries and free to builder.","* Failing to free the builder after you're done using it","* will result in a memory leak","*","* @param bld Builder to free","*/"],"args":"git_treebuilder *bld","return":"GIT_EXTERN(void)","function":"git_treebuilder_free"},{"line":196,"comments":["/**","* Get an entry from the builder from its filename","*","* The returned entry is owned by the builder and should","* not be freed manually.","*","* @param bld Tree builder","* @param filename Name of the entry","* @return pointer to the entry; NULL if not found","*/"],"args":"git_treebuilder *bld, const char *filename","return":"GIT_EXTERN(const git_tree_entry *)","function":"git_treebuilder_get"},{"line":208,"comments":["/**","* Add or update an entry to the builder","*","* Insert a new entry for `filename` in the builder with the","* given attributes.","*","* if an entry named `filename` already exists, its attributes","* will be updated with the given ones.","*","* The optional pointer `entry_out` can be used to retrieve a","* pointer to the newly created/updated entry.","*","* @param entry_out Pointer to store the entry (optional)","* @param bld Tree builder","* @param filename Filename of the entry","* @param id SHA1 oid of the entry","* @param attributes Folder attributes of the entry","* @return 0 on success; error code otherwise","*/"],"args":"git_tree_entry **entry_out, git_treebuilder *bld, const char *filename, const git_oid *id, unsigned int attributes","return":"GIT_EXTERN(int)","function":"git_treebuilder_insert"},{"line":229,"comments":["/**","* Remove an entry from the builder by its filename","*","* @param bld Tree builder","* @param filename Filename of the entry to remove","*/"],"args":"git_treebuilder *bld, const char *filename","return":"GIT_EXTERN(int)","function":"git_treebuilder_remove"},{"line":237,"comments":["/**","* Filter the entries in the tree","*","* The `filter` callback will be called for each entry","* in the tree with a pointer to the entry and the","* provided `payload`: if the callback returns 1, the","* entry will be filtered (removed from the builder).","*","* @param bld Tree builder","* @param filter Callback to filter entries","*/"],"args":"git_treebuilder *bld, int (*filter)(const git_tree_entry *, void *), void *payload","return":"GIT_EXTERN(void)","function":"git_treebuilder_filter"},{"line":250,"comments":["/**","* Write the contents of the tree builder as a tree object","*","* The tree builder will be written to the given `repo`, and","* it's identifying SHA1 hash will be stored in the `oid`","* pointer.","*","* @param oid Pointer where to store the written OID","* @param repo Repository where to store the object","* @param bld Tree builder to write","* @return 0 on success; error code otherwise","*/"],"args":"git_oid *oid, git_repository *repo, git_treebuilder *bld","return":"GIT_EXTERN(int)","function":"git_treebuilder_write"}],"meta":{"file":"git2/tree.h","brief":"Git tree parsing, loading routines","defgroup":"git_tree Git tree parsing, loading routines","ingroup":"Git"}},{"file":"types.h","functions":[],"meta":{"file":"git2/types.h","brief":"libgit2 base & compatibility types","defgroup":null,"ingroup":"Git"}},{"file":"zlib.h","functions":[],"meta":{"file":"git2/zlib.h","brief":"Git data compression routines","defgroup":"git_zlib Git data compression routines","ingroup":"Git"}}]}